# 验签生成规则
* 按照请求参数名称，将请求参数按顺序排列处理，然后组合所有的参数和值进行算法加密。生成验签码sign。
    - 验签的唯一性。通过参数进行加密可以防止参数被篡改。因为参数改变。验签肯定会变。如果不知道加密方式。生成不了正确的验签。就通不过服务端。所以固定的参数组合在一起生成的验签是唯一的。
    - 例如参数是 c=3&b=2&a=1 排序组合后 a=1&b=2&c=3 然后带上时间戳(stamp)以及秘钥(secret)进行算法加密
    - 为什么要排序？排序是为了保证发送端和接收端数据的一致性。排序规则需要和请求的接收端保持一致。
* 参数带上时间戳。
    - 时间戳也要参与验签的加密。
    - 这样可以保证签名的时效性。
    - 后端会判断这个时间戳的时效性。
    - 比对参数上的stamp和服务器上的时间戳时，因为有误差，建议2-5分钟。

# 验签理解
* 1、没有中间层，直接前端请求api服务。
    - 此时验签只是为了防止用户恶意重复请求，防止篡改参数。
    - 加密算法但是很容易被破解，防君子不防小人。
    - 登录会有token，所以还算是安全的。
    - 此时验签和token都是明文暴露的。
    - 没有中间层做代理，token验证权限无法做登录注册的图文验证码码？因为没有sessionid关联，所以就无法识别图文验证码的归属？
        - 方案1：随机token配合redis。
        - 方案2：图文验证码用jsonwebtoken可以做。只需要生成一个图文信息的token存储到。
* 2、有中间层，前端请求中间层，中间层再去根据验签规则去请求api服务。
    - 前端登录，直接请求中间层，中间层把token存session。
    - 此时验签是安全的。token是安全的。
    - 需要中间层启服务，转发api。
    - 本地开发如果和中间层分离了，会存在跨域问题以及sessionid丢失。可以使用服务器代理的方式解决。只要代理设置好了。就不存在这两种问题。
    - 本地开发如果和中间层分离了，没有sessionid进行关联，怎么请求接口验证权限？使用代理服务器，例如使用webpack-dev-server或者browser-sync配置代理，这样sessionid也是可以回传的。
    - 本地开发如果和中间层分离了，没有sessionid进行关联，就无法做注册登录的图文验证码？
        - 前后端分离图文验证码的解决方案1(session)：可以做，使用上面一行里说到的代理是可以把sessionid拿到并设置到cookie上的，因为不存在跨域问题，否则即使获取到了sessionid也设置不到cookie上。
        - 前后端分离图文验证码的解决方案2(token)：利用随机token配合redis是可以做图文验证码的。
        - 前后端分离图文验证码的解决方案3(token)：利用jsonwebtoken生成图文验证码的信息存储到客户端。
    - 不跨主域不用担心sessionid无法关联，跨了主域就使用token吧，跨了主域无法做图文验证码。本地开发可行是因为使用了服务器代理，线上也想做的话，则需要在线上也使用服务器代理。
        - 跨了主域也能做图文验证码。参考上一条即可。
    - 此时用户可以恶意重复请求，如果要防止，则对中间层也做一次验签，这层验签是属于前端的验签，防君子不防小人，此时请用另一把验签秘钥，别傻傻的把api服务的验签秘钥暴露了。此层验签的功能只是为了防止重复请求和参数被篡改。
    - 但是就算是暴露了也没关系，毕竟api服务上还有一层token做权限验证。
    - 加中间层是为了保护api的验签和token。是为了更安全着想。

# 总结
* 前端的验签只是防君子不防小人，防止用户恶意重复请求以及防止篡改参数。
* 跨主域关联sessionid需要使用服务器代理。
