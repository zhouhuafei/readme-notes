# 经历了哪些阶段？
* 1、输入url(一般我们都是输入域名)。
* 2、DNS解析域名，变成目标服务器的实际ip地址。
* 3、建立TCP连接（TCP/IP三次握手）。
* 4、浏览器建立HTTP请求。
* 5、服务器接收并处理请求。
* 6、浏览器接收服务器返回的数据(一般为html)。
* 7、浏览器对html进行解析和渲染。具体步骤如下：
  - 当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。
  - 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
  - 将CSS解析成 CSS Rule Tree 。
  - 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。
  - 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。
  - 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。
  - 重点：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。
* 8、维持TCP连接（`Connection: keep-alive`）。
  - 完成一次`HTTP`请求后，服务器并不是马上断开与客户端的连接。
  - 在`HTTP/1.1`中，`Connection: keep-alive`是默认启用的，表示持久连接，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。
  - 在反向代理软件`Nginx`中，持久连接超时时间默认值为`75`秒，如果`75`秒内没有新到达的请求，则断开与客户端的连接。
  - 同时，浏览器每隔`45`秒会向服务器发送`TCP keep-alive`探测包，来判断`TCP`连接状况，如果没有收到`ACK`应答，则主动断开与服务器的连接。
  - 注意，`HTTP keep-alive`和`TCP keep-alive`虽然都是一种保活机制，但是它们完全不相同，一个作用于应用层，一个作用于传输层。
* 9、断开TCP连接（TCP/IP四次握手）。
  - 通常因超时由服务端主动断开连接。
    - 服务端：FIN - 请求断开tcp链接(第一次挥手)。
    - 客户端：ACK - 确认应答(第二次挥手)。
    - 客户端：FIN - 请求断开tcp链接(第三次挥手)。
    - 服务端：ACK - 确认应答(第四次挥手)。
  - 个人猜测：有`Connection: keep-alive`时，因超时由服务端主动断开链接。无`Connection: keep-alive`时，由客户端主动断开链接。

# 静态资源的加载是在什么时候？
* HTML解析的时候遇到了就加载。

# 浏览器加载css和js以及图片等静态资源是并行的么？
* 是！

# js既然是并行加载，那为什么执行顺序没乱？
* 加载并行，不代表执行也是并行的。
* 默认情况下，js执行顺序和js的请求顺序是一致的。

# css加载？
* css加载不会阻塞DOM树的解析。
* css加载会阻塞DOM树的渲染。
* css加载会阻塞后面js语句的执行。
* 建议：css放在顶部防止渲染错乱。

# js加载？
* js加载和执行都会阻塞DOM树的解析和渲染。
* 建议：js放在底部防止阻塞。

# 图片加载？
* 图片加载不会阻塞DOM树的渲染。因为图片还没加载完的时候，```document.DOMContentLoaded```事件就已经触发了。
* 等图片资源加载完会触发```window.onload```事件。
