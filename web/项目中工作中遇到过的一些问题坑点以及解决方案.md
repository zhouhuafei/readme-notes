* cdn适合费覆盖式发布
     - 因为版本回退之后，还可以引用到以前的静态资源文件。
     - 如果静态资源和当前项目是同一个服务器，不是使用cdn，则覆盖式发布是没啥问题的，因为可以同步更新。

* 后端强缓存，前端打包静态资源时，文件名上加上md5后缀，当内容更新时，更改文件的md5，防止静态资源内容有改动时页面无法更新静态资源。
    - 即使加了md5，有时修改的东西还是会被缓存起来。
    - 案例1，小米手机上自带的浏览器，我把一个网页加入了书签，然后更新网页内容，再从书签进入还是老的内容，除非我手动刷新一下页面，才会展示新的内容。
    - 案例2，手机qq内置的qq浏览器，刷新按钮都没有，下拉也不会刷新，万一被这种浏览器缓存了。呵呵(手动清理缓存或网站里自己加个刷新按钮进行location.reload(true))。特别是微信内置的浏览器(也是qq浏览器，x5内核)，最容易缓存数据，甚至手动刷新都无效（有时连续刷多次才能展示新内容，这个需要看运气和时机。/手动滑稽）。除了手动清理缓存，着实难办。
    - 当然更新内容之后，没被缓存过的手机访问直接就是最新内容。

* 防止回退到某些页面，则从那些页面跳转到别的页面时使用window.location.replace即可。

* 每次都重新new一个组件，也想存数据的话，可以创建一个隐藏的input，把数据存里面，否则就需要把数据绑定到this.opts.config上，弄个checkXXXDataIsExist(检测某某数据是否存在)方法，不存在new，存在只需要触发render(重新渲染，内部只需要判断有数据时怎么渲染即可)，而不走new了，其实也就是构造函数的简单应用，存input是看到同事这样做的，当时没想到这种方法，我表示惊奇了一下，但是我本人是不推荐这种做法的。

* 手机端，商品详情页的商品详情，图片加了max-width:100%还是会超出屏幕
    - 因为商品详情的数据都是别的地方导入的，所以会出现img的父级有固定宽度的情况，这个宽度大于手机屏幕，所以100%，还是大于的。
    - 手机端自适应我使用的是rem，把屏幕宽度分成了10份，所以给商详区域图片加max-width:10rem即可。

* 手机端弹出的键盘里怎么出现搜索按钮
    - 在input标签里面把type设置为search就可以了。弹出的手机键盘回车键也会变成搜索或者是搜索的图标。<input type="search"/>
* 手机端弹出的键盘里有个搜索按钮，如何监听搜索按钮的点击事件？
    - 方案1.点击软键盘上搜索按钮的时候会默认触发form的sumit事件。因此只需要监听form的submit方法即可。搜索完之后可以关闭软键盘document.activeElement.blur(); // 软键盘收起
    - 方案2.input的onsearch事件。input的类型值type需要为search。去掉搜索时，后面跟着的差号。
    ```
        input::-webkit-search-cancel-button{
            display: none;
        }
    ```

* 移动端使用轮播插件时谷歌浏览器报错 Unable to preventDefault inside passive event listener due to target being treated as passive
    - 解决方案 轮播条目里加上touch-action: none; 即可

* 微信内置浏览器，使用表单提交数据进行搜索商品，点进商品详情页，再回退，有很大的几率触发无网页面（无法打开页面，点击空白处刷新，诊断网络）
    - 问题原因: 进入商详页，回退，如果页面没加载完，会直接回退到表单提交之前的那个页面（可以简单的理解为连续回退了两次）。此时就会触发上面的问题。
    - 解决方案1 使用ajax进行数据检索。返回json。前端拿到数据渲染页面。
    - 解决方案2 a标签直接跳 /url/search/?keywords=关键字 后端直接渲染。

* jq/zepto ajax执行顺序 success error complete

* 微信内置浏览器不支持外链下载，请长按图片进行下载。

* title标签，如果有两个，后面的则会被前面的覆盖。也就是说，第一个title标签会生效，后续的都无效。(随手记一下)

* 移动端输入框在底部会被键盘遮挡的解决方法
    - 方案1
    ```
    setTimeout(function () {
        document.body.scrollTop = document.body.scrollHeight;
    }, 300);
    ```
    - 方案2
    ```
    Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内。
    而 Element.scrollIntoViewIfNeeded() 是 Element.scrollIntoView() 的变体，如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。
    以上，应用最多的场景应该是在移动端，当表单元素获得焦点的时候滚动到视野中，避免软键盘遮挡元素。
    鉴于Element.scrollIntoView无论设置什么参数，且不论是否在视野中都会滚动的特点，Element.scrollIntoViewIfNeeded特性应该比Element.scrollIntoView体验好。
    ```
