# 构造函数B,继承构造函数A上原型的方法。
```
function A () {
    this.name = 'hello world';
}
A.prototype.getName = function () {
    return this.name;
}

function B () {
    A.call(this); // 继承属性
    this.sex = 'girl';
}
```
* 方法1:
    - 原型链直接指向，未改变B的原型，所以不存在引用。
    ```
    B.prototype.__proto__ = A.prototype;
    ```
* 方法2:
    - 直接赋予一个空对象，所以不存在引用。这个方法和方法1有点类似，但是又有所不同。
    - Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
    - 需要纠正constructor属性
    ```
    const obj = Object.create(A.prototype);
    obj.constructor = B;
    B.prototype = obj;
    ```
* 方法3：
    - 属性全部赋值，所以不存在引用。
    ```
    for(var attr in A.prototype){
        B.prototype[attr] = A.prototype[attr];
    }
    ```
* 还有其他方法，就不一一列举了。例如es6的语法糖，class和super关键字，让继承变得更容易。
