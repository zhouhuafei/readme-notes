# 微信开发者工具
* 编译模式，定格在某一个页面时，启动参数设置成：?id=3549。导致一直报错
    - 解决方案，去掉问号(?)。

# 跳转
* wx.navigateTo
    - 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。
* wx.redirectTo
    - 关闭当前页面，跳转到应用内的某个页面。
* wx.reLaunch
    - 关闭所有页面，打开到应用内的某个页面。
* wx.switchTab
    - 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。
    - 注：此方法路径后不能带参数。其他三个方法可以。
    - 解决switchTab路径后不能带参数的问题：使用reLaunch或者使用本地存储把想要携带的参数存储起来。

# 页面之间传值
* 方式1
```
// 在首页，使用api跳转到详情页
wx.navigateTo('/pages/detail/detail/?id=1');
// 在详情页页面中的onLoad方法中接收
Page({
    onLoad(query) {
        console.log('接收数据', query);
    },
});
```
* 方式2
```
// app.js里定义一个全局变量。
App({
    globalData: {},
});
// 跳转到别的页面的时候，可以更改这个值。
const app = getApp();
app.globalData.key1 = 'value1';
// 在其他页面就可以拿到这个值了。
const app = getApp();
console.log('数据', app.globalData.key1);
```
* 方式3
```
// 通过本地存储，跳转页面之前设置一个值。
wx.setStorage('key1', 'value1'); // 异步的
wx.setStorageSync('key1', 'value1'); // 同步的
// 到另外一个页面时，再接收这个值。
wx.getStorage('key1', 'value1'); // 异步的
wx.getStorageSync('key1', 'value1'); // 同步的
```

# 事件
* 传参
```
// wxml
<view bindtap="fnClick" data-id="123"></view>
// js
Page({
    fnClick(ev) {
        console.log('数据', ev.currentTarget.dataset.id);
    },
});
```
* target和currentTarget：
    - `target`(点击谁就是谁)触发事件的组件的一些属性值集合。
    - `currentTarget`(事件绑给谁就是谁)当前组件的一些属性值集合。
* bind和catch：
    - `bind`(不会阻止冒泡)事件绑定不会阻止冒泡事件向上冒泡。
    - `catch`(可以阻止冒泡)事件绑定可以阻止冒泡事件向上冒泡。

# WebStorm 格式化
* WebStorm 格式化wxss文件时，导致数值和单位之间有空格，正常应该是20rpx，编辑器格式化成了20 rpx导致无效。
    - 解决方案，不格式化，或者使用sass工具，封装个函数去转义。
    ```
    @function px2rpx($px) {
      @return $px * 1rpx;
    }
    ```

# 针对某一个页面进行下拉刷新
* `index.json`里加上`"window":{"enablePullDownRefresh":true}`，下拉刷新无效。
    - 问题：上述是全局的配置方式，需要在`app.json`里配置。
    - 解决方案：需要注意的是在需要下拉刷新的页面设置`json`时，直接写`enablePullDownRefresh`属性就行了，不需要写`window`。
* 下拉刷新能全局配置么？
    - 能。在`app.json`的`window`属性里加上`"enablePullDownRefresh":true`属性即可。
* 下拉刷新，重新执行onLoad，组件内部数据没更新。
    - 解决方案：先把数据变成空，然后再重新赋值。然后关闭下拉刷新。wx.stopPullDownRefresh();
    - 新坑：重新执行onLoad()，导致onLoad(options){}函数中，options变为了undefined。
    - 新坑解决方案：把options存在data上，刷新时把数据带过去即可```this.onLoad(this.data.options)```。
    - 补充：微信小程序页面内置的this.options属性直接就可以获取到页面入参，如果在套模版时没有使用到options则没必要把options绑定到data上。
* 下拉刷新时(正常思维)，data上除去options的其他数据都设置成默认状态。然后重新执行```this.onLoad(this.data.options)```。
    - 有定时器要清理掉定时器。
    - 有分页数据则要重置为默认数据。
    - 有列表数据则要重置为空。
* 下拉刷新时(这样也行)，data上全都默认为null。或者data上不设置数据(经过测试，只要使用setData设置上的数据即可渲染到视图层，即data上没必要设置上数据的默认值)。
    - 在onLoad的时候使用```this.setData```设置所有数据的默认值(可提取成一个方法，名字我都想好了就叫setDefaultData)。注：如果有定时器要先清理一下定时器(在设置默认数据之前)。
    - 下拉刷新的时候重新执行```this.onLoad(this.data.options)```。
* 下拉刷新时(建议如此)，定一个默认数据模型方法(方法可以防止对象引用，名字我都想好了就叫getDefaultData)，方法中返回一个对象。然后给data赋值默认值的时候调用这个方法即可。
```javascript
const ApiGroup = require('../../api/group.js')

function getDefaultData (options) {
  const obj = { // 默认值
    resData: {},
    options: {}
  }
  if (options) { // 根据options重置默认值
    obj.options = options
  }
  return obj
}

Page({
  data: getDefaultData(),

  onLoad (options) {
    this.setData(getDefaultData(options))
    ApiGroup.info({
      data: {
        groupId: options.groupId
      },
      success: (res) => {
        this.setData({ resData: res.data })
      }
    })
  },

  onPullDownRefresh () {
    this.onLoad(this.data.options)
    wx.stopPullDownRefresh()
  },

  returnPrevPage () {
    wx.navigateBack({
      delta: 1
    })
  }
})
```
* 下拉刷新偷懒的做法：重定向到当前页面。上面重新触发onLoad的方式也是类似的理念。如果有定时器，页面卸载时(onUnload)清一下即可。因为redirectTo会触发onUnload钩子。
```javascript
Page({
  onPullDownRefresh () {
    wx.stopPullDownRefresh()
    const pages = getCurrentPages()
    const currentPage = pages[pages.length - 1]
    const url = currentPage.route
    let options = currentPage.options
    options = Object.keys(options).map((item) => `${item}=${options[item]}`).join('&')
    wx.redirectTo({ url: `/${url}?${options}` })
 }
})
```

# 分页
* 页码自增如果放在请求完成之后。
    - 则需要判断当前在否在加载中？加载中不允许继续请求(必须判定，否则多次拉到底部会重复请求同一页码数据)。
    - 加载之前判断当前页码是否已超总页码？超出不允许请求。
* 页码自增如果放在请求之前。
    - 则需要判断当前在否在加载中？加载中不允许继续请求(非必须判定，多次拉到底部页码会自增)(建议判定，否则可能会出现后请求的先给了响应以至于顺序错乱)(如果想偷懒，可以不判定，但是会留下这个隐藏bug哟)。
    - 加载之前判断当前页码是否已超总页码？超出不允许请求。

# canvas组件
* canvas-id属性如果不加，canvas组件会一直是display:none。
    - 注意：不是id属性，是canvas-id属性。
* canvas 让px可以自适应，原理就是等比缩放。
```
function px2remCanvas(px) {
    return px * wx.getSystemInfoSync().windowWidth / 375; // 设计图是375的。
}
```
* canvas转图片时：1、canvas里用wx.drawImage插入的图片，真机本地预览进行测试，发现图片不显示。2、导出的图片变形了。3、导出的图片没有背景色。
    - 1、解决方案之wx.drawImage插入的图片，真机本地预览进行测试，发现图片不显示：
        - 1、图片需要是本地图片。
        - 2、不支持svg格式。
        - 3-1、远程图片需要下载到本地 可以使用wx.downloadFile方法或者wx.getImageInfo方法。
        - 3-2、远程图片仅支持https协议的图片。
        - 3-3、开发者工具，预览时用真机是无效的，预览开启调试模式时真机是有效的，远程调试时用真机是有效的。
        - 3-4、调试模式，不校验域名。导致真机上wx.drawImage无效的原因是，网络图片的链接不在小程序的信任列表中，需要管理员去后台把链接加入白名单。
        - 3-5、downloadFile，需要在小程序公众后台配置相应的downloadFile域名，否则会无法正常使用。
    - 2、解决问题之宽高不对：
        - 1、因为wx.canvasToTempFilePath方法导出的图片默认宽高是小程序去掉顶部菜单的宽高（如果画布的宽高不是这个比例，则导出的图片会变形），应该设置成画布的宽高乘以对应的倍数，先3倍吧。
        - 2、然后再配合wx.saveImageToPhotosAlbum方法进行导出。
    - 3、解决方案之背景色无效：因为我使用的是css的背景色，所以无效，背景色应该也要使用canvas绘画出来。
* canvas海报太慢了。
    - 解决方案：下载一次就存储起来，把原url也存储起来。如果原url更新了（图片更新了），就重新下载并存储。
    - 如果还觉的慢，就在前一个页面进行提前下载并存储，让用户无感知。然后来到当前页时，判断，如果前一个页面已经把图片下载好了，就直接使用，否则当前页进行重新下载并存储。
    - 注意事项：如果你是判断存储的已经有了，就直接使用存储的。那么你就需要去注意后续的数据更新，例如海报图片更换了，你就要重新生成最新的海报。
* 如果使用v-if控制canvas，下次显示时，会导致绘画无效，原因没有排查。建议使用display:none和display:block控制canvas的显示隐藏。
* font
    - 微信小程序中，font属性对应的值里，如果fontSize带小数，会导致设置失败，变成默认的10px sans-serif。浏览器中无这种问题。
    - 解决方案：向下取整。向上取整。四舍五入。
* 微信小程序中，canvas绘画时，在代码最后，代码最后，代码最后要执行一次ctx.draw();方法。绘制的才有效果。
* clip路径裁切，如果在save和restore之间，可以直接裁切，不用担心后面被影响，如果不是的话。建议fill填充一下，否则后续别的路径填充如果影响到了，会导致覆盖掉填充的图片（微信小程序模拟器上才有这个坑）。真机测试不fill一下，也是可行的。
* ctx.scale真机上导致多次缩放。
    - h5的canvas使用save和restore可以解决这种问题。
    - 微信开发者工具的模拟器上没有这种问题。
    - 真机上难道只能内部处理坐标么？是的，真机上我目前的解决方案是，内部坐标封装函数进行缩放处理。
    ```
    const px2remCanvas = function (px) { // canvas自适应
        return px * wx.getSystemInfoSync().windowWidth / 375; // 设计图是375的。
    };
    const px2px = function (px) { // canvas缩放
        return px2remCanvas(px) * scale; // scale是canvas的缩放比例。
    };
    ```

# web-view组件
* web-view会铺满全屏，并覆盖其他组件。
    - cover-view组件也会被覆盖。
    - web-view加高度无效，就是会铺满全屏。
* web-view内h5页面回跳小程序，直接运行js回跳无效。
    - 解决方案：加定时器。
    ```
    setTimeout(function () {
        // 此处运行js，跳回小程序，不加定时器回跳无效。原因不知，解决方案是我猜出来的。
    }, 60);
    ```
* web-view内部不能调起微信支付。
    - 解决方案：web-view中下完单之后，带着订单号回跳到小程序端。然后用订单号去打后端接口获取支付需要的数据，然后再拿这些数据去调起小程序端的支付。

# 页面转发
* 如果Page上配置的有onShareAppMessage方法，右上角菜单就可以有转发功能，当然，不想有转发功能，去掉就行了。例如分销员页面，有些人开启了，有些人没开启，所以就不能有转发，否则需要判断跳转。
* 在return的对象{}中，加上success回调，即可监听到转发成功。
* 配置了onShareAppMessage方法之后怎么禁止掉右上角的转发？
    - 解决方案：在页面监听事件的onLoad事件中，直接触发wx.hideShareMenu();即可屏蔽右上角的转发。
* 分享转发的网络图片，域名也需要在小程序管理后台的下载域名列表里添加了才可以转发出去。

# getStorageSync
* ```wx.getStorageSync('distributor_id')```。如果在data时就赋值获取或者直接值赋给一个变量，在某些机型会丢值。真是见了鬼了，这根本无解好吧，原因不明。
    - 我怀疑是SDK版本问题。因时间原因（通宵上线，先保障功能正常，不能浪费大家的时间），不能在有问题的机器上进行测试。
    - 解决方案：哪里需要就直接获取```wx.getStorageSync('distributor_id')```。当然同事也更换了版本(2.2.2 -> 2.2.5)。因两者是同时进行，所以到底是这么解决的，有待考察。
    - 我本地用的2.0.4版本，未发现异常。不使用变量赋值之后，同事将SDK切回2.2.2版本，发现也可以获取到数据了，可是这让人无法理解啊。虽然事实摆在眼前，但是我个人仍然感觉是SDK版本有问题的可能性更高一点。

# bindblur
* 真机测试：输入完毕点击按钮的一瞬间是空值。
    - 解决方案1：使用bindinput代替bindblur。
    - 解决方案2：点击之后，延迟一下，个人不喜欢这种方式。

# onShow
* 因为使用onShow，data上的数据，不会每次都初始化。例如默认isShow1是false。isShow2是false。满足条件则变为true。
    - 第一次进来时，满足条件我让isShow1变成了true。
    - 第二次进来时，满足条件我让isShow2变成了true。但是我还要isShow1变成默认的false。
        - 此时，data上的数据是不会自动初始化把isShow1变成false的。
        - 需要手动把isShow1和isShow2变成false，然后继续打接口判断，满足条件让对应的变成true。
* 总结：onShow不会初始化data上的数据，如果需要初始化，则需要手动处理。

# 回退，数据不更新，还是老数据
* 解决方案：onShow里调this.onLoad();但是这样做，有问题，因为初始访问会同时调用onLoad和onShow，所以正确解法是：使用onShow代替onLoad即可。
* 如果onload里有options，把options存到data上，然后调用this.onLoad(this.data.options);
* onShow不会更新data上的数据，有些状态如果需要初始化，则需要手动进行初始化。特别是一些按钮默认隐藏，后续触发了显示，可能就一直显示了。需要在onShow时，全部重置成不显示的。

# button组件去掉默认边框和圆角
* button组件上的边框和圆角是写在伪元素after上的，所以要对伪元素after处理才行。

# wx.login 和 wx.getUserInfo 以及获取手机号和获取openid
* wx.login可以用来获取临时登录凭证code，然后使用这个凭证code可以获取session_key 和 openid 等。
* wx.getUserInfo授权之后才能使用。```<button open-type="getUserInfo" bindgetuserinfo="bindGetUserInfo">点击进行授权登录</button>```
* 获取openid：
```
getOpenId(callback) {
  const that = this;
  const openId = wx.getStorageSync('open_id');
  if (openId) {
    callback(openId);
  } else {
    wx.login({
      success({ code }) {
        const userInfo = wx.getStorageSync('userInfo'); // 此处建议使用wx.getUserInfo。且建议不缓存。否则后续更新是个问题（后续需要更新的数据，都不建议进行长期存储）。
        that.ajax({
          url: 'wechat/getOpenId',
          data: { code, ...userInfo },
          isOpenId: true,
          success({ data }) {
            if (data.res === 'succ') {
              const result = data.result || {};
              userInfo.tel = result.tel || '';
              wx.setStorageSync('userInfo', userInfo);
              wx.setStorageSync('open_id', result.openid);
              wx.setStorageSync('session_key', result.session_key);
              callback(result.openid);
            }
          },
        });
      },
    });
  }
}
```
* 获取手机号：```<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber">授权手机号</button>```
```
getPhoneNumber(e) {
  const that = this;
  if (e.detail.errMsg === 'getPhoneNumber:ok') {
    ApiWechat.getPhone({
      data: {
        iv: e.detail.iv,
        encryptedData: e.detail.encryptedData,
      },
      callback(res) {
        if (res.phoneNumber) {
          that.setData({ show: false });
          app.globalData.userInfo.tel = res.phoneNumber;
          that.setMsg();
        }
      },
    });
  }
}
```

# App有onLaunch没有onLoad
* Page有onLoad没有onLaunch
* App和Page都有onShow和onHide

# 函数封装
* 源码：https://github.com/zhouhuafei/zhf.canvas-api/blob/master/src/index.js
* 功能：绘制多行文字，绘制圆角矩形等。

# 其他1
* 微信小程序中是没有Image，document，window等BOM和DOM对象的。

# rpx
* 750设计图 1rpx等于1px。
    - 单位要写成rpx。
* 375设计图 1rpx等于0.5px。1px等于2rpx。
    - 375设计图，量取的单位是10px，则要写成20rpx。建议使用scss处理。
* 如果你直接使用px作为单位，则微信会把1px转成2rpx。（注意，注意，注意，其实这里不是微信转的，是工具postcss转的。所以这里的总结是错误的。）
    - 个人觉的这里是为了兼容某些手机端ui框架，因大多数手机端ui框架都是使用的px。
    - px单位的ui组件可以使用postcss转成rem的。

# swiper和canvas
* 内嵌能在可视区展示的canvas组件会导致卡顿。
* 如果内部想展示，使用image组件展示即可。把canvas转成base64形式的数据，然后赋值给图片的src，即可展示出来。
* 可使用npm上的upng-js包模块的encode方法配合wx.arrayBufferToBase64方法实现功能。
* 坑点：canvasGetImageData需要在canvas绘画完毕之后进行获取。否则会是空的。draw的回调中还是需要定时器配合，否则获取还是为空，这可能是个bug。
```
// 绘制海报1
drawGoodsPoster1(v, v.scale, () => {
  setTimeout(() => {
    const w = Math.floor(v.width * getCanvasRatio()); // 因canvas自适应，这里要处理一下，此处得到的是自适应之后canvas的宽。
    const h = Math.floor(v.height * getCanvasRatio()); // 因canvas自适应，这里要处理一下，此处得到的是自适应之后canvas的宽。
    wx.canvasGetImageData({
      canvasId: v.id,
      x: 0,
      y: 0,
      width: w,
      height: h,
      success(res) {
        const arrayBuffer = upng.encode([res.data.buffer], w, h); // 转成utf-8数据
        v.imageBase64 = `data:image/png;base64,${wx.arrayBufferToBase64(arrayBuffer)}`;
        self.setData({ canvasSave });
        console.log(`canvasGetImageData${i}：`, res, arrayBuffer, v.imageBase64, getCanvasRatio(), v.width, v.height, w, h);
      },
    });
  }, 500);
});
```
* wx.canvasGetImageData在性能不好的机器上连续调用两次，即使使用了定时器延迟，也是会fail，所以以上方法行不通。
    - 使用wx.canvasToTempFilePath返回url直接给image组件使用即可。没必要使用base64。
* wx.canvasToTempFilePath报错：```canvasToTempFilePath:fail:create bitmap failed```
    - 原因：canvas元素不存在。应该在v-if满足条件的时候进行绘制。或者使用class控制显示隐藏。
* canvas层级太高，覆盖了底部导航。
    - 覆盖的是自定义的底部导航，覆盖不了在app.json里配置的导航tabBar。
    - 解决方案1：使用cover-view标签重写底部导航。
    - 解决方案2：使用cover-view标签包裹canvas标签，再给包裹的cover-view标签加小于底部导航的层级(z-index)即可。
    - cover-view标签的使用限制请看文档： https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html
    - 注意事项：仅支持最外层的cover-view标签使用```position: fixed```。
    - 其他：view组件无法覆盖原生组件，cover-view组件能覆盖原生组件，view组件层级(z-index)高于cover-view组件时能覆盖cover-view组件。
* cover-view踩坑
    - 问题：iconfont无效。解决方案：优雅降级，用图片代替icon。
    - 问题：button类型如果是功能型，真机上点击无效。解决方案：button标签中包裹上内容即可。
* swiper来回抖动
    - 问题重现：小程序切到后台，过段时间再切回前台就会如此。
    - 原因：因使用this.setData修改了swiper上的current属性导致的。
    - 官方解释：如果在 bindchange 的事件回调函数中使用 setData 改变 current 值，则有可能导致 setData 被不停地调用。
    - 解决方案：不要修改swiper上的current属性，如果需要使用索引，可定义一个变量在bindchange中接收索引。

# 其他2
* 获取用户信息失败，说明没授权登录，或者授权登录失效。
    - 需要把用来判断是否登录的字段移除掉。以保证可以再次跳到授权页面。
    ```
    wx.getUserInfo({
        success: (res) => {
        },
        fail: (err) => {
            console.log(err);
            wx.removeStorageSync('isLogin'); // 获取用户信息失败，说明没授权登录，或者授权登录失效。移掉此项，后续判断是否登录就通不过了，可以避免不必要的bug。
        },
    });
    ```

* 有open_id就算是登陆了。但是如果获取不到userInfo或者授权过期导致获取失败也是问题。
    - 所以正确逻辑应该是有open_id以及userInfo才算登录。
    - 封装login方法，在里面获取open_id以及userInfo。获取open_id成功则存储起来，获取userInfo成功则存一个hasUserInfo:true。因open_id不会变动，userInfo会变动，会变的都不建议存储起来。
    - 封装isLogin方法，在storage中检测到open_id以及hasUserInfo就算是登陆了。
    - 处理wx.getUserInfo方法。如果获取用户信息失败(如果失败原因是用户未授权)，就移掉关键字段open_id或者hasUserInfo(让isLogin方法通不过)，并跳转到授权登录页进行登录。

* project.config.json应该添加到git的版本库。
    - 如果不同的线对应着不同的品牌小程序，例如微好店小程序和微商城小程序，代码相同，appid不同。
    - 如果不在git的版本库里，做项目的时候，一切线，appid没变化，就会有问题。如此情况就只能曲线救国，例如用git再拉一份代码进行配置。
    - 如果在git的版本库里，就不会出现上面这种狗血的问题。

# css
* 不支持```*```号匹配。
* 不支持```.div > :nth-child(n){}```。
* 不支持使用本地背景图片。

# css3
* css3之sticky悬浮导航(存在兼容性问题，小程序中可以使用)。
    - 滚动到class为sticky的标签时，标签会自动悬浮。
    - 如果top为100px，则滚动到标签top距离顶部100px的位置时就悬浮。
    ```
    .sticky {
      position: -webkit-sticky;
      position: sticky;
      top: 0;
      z-index: 9999;
      background: #ff0000;
    }
    ```

# wx.chooseImage
* count为1在模拟器上测试时是正常的。
* count大与1时，例如为2，依然可以选择超过2张图片。
    - 虽然选择的图片个数超过了2个，但是接口的个数依然是2个，所以这不算是个大坑。

# 定时器
* 页面卸载(onUnload)要清理掉定时器，否则会导致报错（以前会导致报错）。如果不清理掉，定时器会一直走着。
    - 因为navigateTo不会触发onUnload。所以后续如果是通过navigateTo又跳进了有定时器的页面，内存里则有两条定时器在走着，虽不会影响页面上的数据(已测试)。但内存会被占的越来越多。
    - 虽navigateTo会触发onHide钩子，但是一般不会在onHide钩子中清理掉定时器，否则后退时(onShow)就算重启了定时器，时间也不准了。
    - 如果非要在onHide时，清理掉定时器，那么onShow时就要重新渲染页面拿数据拿时间。注：如此场景下，在onUnload时也要清理掉定时器。因onHide和onUnload的触发场景不一样。
    - onUnload 页面卸载时触发。如wx.redirectTo或wx.switchTab或wx.reLaunch或wx.navigateBack到其他页面时。
    - onHide 页面隐藏/切入后台时触发。 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。
* 如果使用navigateTo跳转则不用清理定时器，因为可以回退。
* 如果使用redirectTo跳转则建议清理掉定时器，因为无需回退。
* 总结：定时器如果不清理则会一直在内存中执行。
    - 举一反一：vue-router后退会触发上个页面的created和mounted钩子以及当前页面的destroyed钩子。即：后退会重新请求数据等。所以如果页面有定时器的话，应该在destroyed钩子清理掉。
    - 举一反一：vue-router跳页面也会触发当前页面的destroyed钩子。而微信小程序的navigateTo不会触发onUnload。

# onLoad和onShow以及onReady的执行顺序
* 文档：https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html
* `onLoad`：页面加载，一个页面只触发一次
* `onShow`：页面显示
* `onReady`：页面初次渲染完成，一个页面只触发一次
* 触发顺序：`onLoad > onShow > onReady`
    
# 点击微信小程序右上角的圆圈会触发哪些生命周期？
* 方式一：
    - 点击圆圈时。会触发。page的onHide。然后触发app的onHide。
    - 然后通过手机的菜单再次进入时，会触发。app的onShow。然后是page的onShow。如此操作流程不会触发页面的onUnload。
* 方式二：
    - 先把页面转发出去。此时。会触发。page的onHide。app的onHide。app的onShow。然后是page的onShow。
    - 然后点击圆圈。此时。会触发。page的onHide。然后触发app的onHide。
    - 然后通过分享卡片点进去。此时。会触发。app的onShow。
        - 因草动小程序点击分享卡片进去会重新登录并重定向(路由栈被清理)。
        - 故而：然后是page的onUnload。然后是page的onLoad。然后是page的onShow。
        - 否则：
            - 非tabBar页面：然后是page的onLoad。然后是page的onShow。
            - 是tabBar页面但是我之前没访问过：然后是page的onLoad。然后是page的onShow。
            - 是tabBar页面但是我之前访问过：然后是page的onShow。

# 在小程序中设置了数据setData，在插件中居然拿不到值？
* 原因：代码放在了Page构造器的上面。
* 解决方案：把getData放到onLoad钩子中即可。
* 传值的原理：其实就是修改模块中定义好的值(类似闭包)。

# 在小程序中明明可以直接分享插件内页，为什么非要做个share中转页？
* 因为智障。
    - 不仅仅是因为智障。如果跳入插件页需要带参数进去。可以在外部落地页进行统一处理。
* 插件应该是一个独立的第三方服务，外部只需要传入appid。
* 插件内部根据appid和open_id进行用户识别。

# 组件中使用字体图标
* 方案1：在组件中引入字体图标。
* 方案2：在使用组件的页面中引入字体图标。

# 二维码
* getWXACodeUnlimit 小程序生成二维码报错
* 41030	所传page页面不存在，或者小程序没有发布

# 解决小程序指定页面没审核通过，二维码测试环境生成不了的问题。
* 做一个中转页，二维码都指向到这个中转页。再通过中转页跳入指定页面。

# 小程序插件瘦身
* 公用样式和字体使用wxss文件。建议都使用wxss文件。因为scss会把import的文件杂糅到页面中(即使是wxss文件)。
* 如果非要使用scss。则建议把import```/*import 'xxx.wxss'*/;```的部分注释掉。当把scss转成wxss之后，再使用```gulp-batch-replace```替换掉注释。
    - 引入的时候引入注释版本的wxss。
    ```
    /*@import "/scss/iconfont.wxss";*/
    /*@import "/scss/common.wxss";*/
    ```
    - 打包的时候把指定的scss文件转成wxss文件。然后再把wxss文件中被注释的@import部分释放掉。
    - 最优解：使用微信原生的wxss文件。因为使用原生wxss互相引用(@import)的话不会导致内容增加。
    - 最优解难点在于如何配合scss使用。
        - 我个人建议生成一个公用的common.wxss样式文件。```common.scss -> common.wxss```
        - 然后内部引入iconfont.wxss文件。```iconfont.scss -> iconfont.wxss```
        - 其他页面全部都引入common.wxss文件即可。
        - gulp dev-wxss dev-scss 都要处理。
* 压缩js。
* 不要使用很大的第三方工具包。
* 不要压缩css或者使用正确的包去压缩css：因使用gulp-clean-css会把import的wxss文件中的内容杂糅到页面中。所以我个人不建议你去使用gulp-clean-css压缩css。
```
// 此处省略部分
gulp.task(`dev-scss`, function () {
  return gulp.src(['src/**/*.scss'])
    .pipe(plumber())
    .pipe(sass())
    .pipe(rename((path) => {
      path.extname = '.wxss';
    }))
    .pipe(px2rpx({
      screenWidth: 375, // 设计稿屏幕, 默认375
      wxappScreenWidth: 750, // 微信小程序屏幕, 默认750
      remPrecision: 6, // 小数精度, 默认6
    }))
    .pipe(replace([
      ['/*@import "../../scss/_iconfont.wxss";*/', '@import "../../scss/_iconfont.wxss";'],
      ['/*@import "../../scss/_reset.wxss";*/', '@import "../../scss/_reset.wxss";'],
    ]))
    .pipe(gulp.dest(`dist/`));
});
const uglifyes = require('uglify-es');
const uglify = require('gulp-uglify/composer')(uglifyes, console);
gulp.task(`dev-js`, function () {
  return gulp.src('src/**/*.js')
    .pipe(plumber())
    .pipe(uglify({
      ecma: 8,
      output: {
        // 最紧凑的输出
        beautify: false,
      },
      compress: {
        // 删除所有的 `console` 语句
        drop_console: isProduction,
      },
    }))
    .pipe(gulp.dest(`dist/`));
});
```

# 小程序怎么写转插件才会方便一点？
* 1、不要往```全局对象app```上绑定方法。因为插件中不能使用```getApp()```方法。
* 2、引入组件使用相对路径。
    - 因在插件中如果使用绝对路径需要带上/插件appid/xxx/yyy/。
    - 如果后续不做成插件，那么组件肯定是引入绝对路径更好用。

# 全局组件
* 组件的引入放到app.json的usingComponents属性上即可全局使用此组件。
    - 在其他组件中亦可直接使用。

# 插件
* ```<web-view />```不能插件中使用。

# 类似3D轮播图的实现原理
* 使用小程序自带的swiper组件。
* circular：是否无缝滚动。
* previous-margin：与上一张图片的间距。
* next-margin：与下一张图片的间距。
* 然后再设置非当前图片的层级和透明度以及高度。

# 修改placeholder样式
* ```placeholder-class="placeholder"```。

# 输入框placeholder文字抖动
* 官方的也抖。

# 垂直居中时某些机型 display: flex; align-items: center 对不齐
* 是因为高度和行高不一致导致的。
* 建议：给设置了flex居中的元素加高度加行高。否则有些机型会对不齐。微信开发者工具体现出来的就是如此。
* 单个英文字母偏下，例如：g、s。
    - 无解。

# 使用flex让价格底部对齐，结果字体大的价格有些偏上。
* 大的价格行高调整为零点几即可。

# onReachBottomDistance
* 单位是px。是相对手机屏幕宽度的。不是相对于750的。所以配这个值的时候要相对的写大一点。
* 在app.json中要配置到window属性里(页面上的属性如果要全局配置到app.json中，则都要配置到window属性里)。

# canvas图片宽度自适应
* ```wx.getImageInfo```可以获取图片的宽、高、类型、拍照方向、本地路径。
    - 获取图片信息。网络图片需先配置download域名才能生效。

# 获取组件距离顶部的距离以及滚动到指定距离
```javascript
// 创建节点选择器
const query = wx.createSelectorQuery();
// 选择id
query.select('#the-id').boundingClientRect();
query.selectViewport().scrollOffset();
query.exec(function (res) {
  console.log(res[0].top); // #the-id节点的上边界坐标
  console.log(res[1].scrollTop); // 显示区域的竖直滚动位置
  wx.pageScrollTo({
    scrollTop: 0,
  });
});
```

# 组件中选择器的应用
* 在组件中建议只使用class选择器，否则会抛错：```Some selectors are not allowed in component wxss, including tag name selectors, ID selectors, and attribute selectors```

# 下拉加载更多
> 暂无数据 没有更多数据 加载中
* 我之前封装这个组件，做了太多没意义的动作，例如监听properties中result的值，然后改变isShowLoading的值等。其实根本没必要。
* 直接拿properties中result提供的值进行套模板即可。result中提供的有当前页数，总页数，当前页数据条数，总数据条数。

# 组件构造器上的externalClasses属性和options.styleIsolation属性。
* externalClasses很有局限性，无法覆盖组件内已有样式。【加!important可以覆盖】
* options.styleIsolation设置为apply-shared可以在页面上覆盖子组件样式。
* 再测试一次externalClasses能否覆盖掉组件内的样式。
    - 经过再次测试，发现结果不变，依然还是无法覆盖组件内已有的样式。【加!important可以覆盖】
    - 但是如果组件样式写的精巧以及externalClasses属性对应的样式写的恰当，还是会发挥出应有的功能的。
    ```
    /* 组件 custom-component.js */
    Component({
      externalClasses: ['my-class']
    })
    <!-- 组件 custom-component.wxml -->
    <view class="my-class">使用组件时，组件上my-class属性对应的值，会取代掉这里的my-class。</view>
    ```
    ```
    <!-- 页面的 WXML -->
    <custom-component my-class="red-text" />
    <custom-component my-class="large-text" />
    <!-- 以下写法需要基础库版本 2.7.1 以上 -->
    <custom-component my-class="red-text large-text" />
    ```
* 再二次测试externalClasses时，我发现，只需要给外部样式类加上!important就可以覆盖组件内的样式了。

# navigator踩坑
* 问题1：互相嵌套某些机型会穿透。
* 问题2: 在标签中使用bindtap会冒泡。
* 解决方案：使用```catchtap```。
    - 给标签直接加一个```catchtap```属性即可阻止默认行为。如果需要执行一些操作，可以```catchtap="fnName"```。
* 其他
    - 网页上a标签不能嵌套a标签。
        - 但是a标签可以套div。
        - a套div，div再套a，也是不行的。```<a href=""><div><a href=""></a></div></a>```会变成如下：
        ```html
        <a href=""></a>
        <div>
          <a href=""></a>
          <a href=""></a>
        </div>
        ```
        - p标签不可以套h1-h6不可以套div等其他块元素。```<p><h2></h2></p>```会变成如下：
        ```html
        <p></p>
        <h2></h2>
        <p></p>
        ```
        - 大多数情形下，内敛标签不允许嵌套块级标签。
    - 网页上使用定位让两个a标签重叠。点击a标签的时候，是不会穿透的。
    - HTML中在a标签中添加onclick事件。链接的onclick事件被先执行，其次是href属性下的动作。
    - 微信小程序中navigator标签，bindtap会被触发，至于先手顺序，我不清楚，理应同上。

# 登录统一处理
* 发送请求之前先检测有没有登录，没登录则调登录方法进行登录处理。
* 打接口如果提示登录过期了，则重新调用登录方法。
* 需要注意的是，如果当前正在登录，则不重复登录。定一个全局变量监控即可。

# 页面渲染时怎么防止wx:if抖动？
* 场景描述：userType有两个值staff和customer。判断使用wx:if="{{userType=='staff'}}"和wx:else判定。data上userType默认值是customer。onLoad中```this.setData({ userType: wx.getStorageSync('userType') || 'customer' })```。
* 问题描述：如果类型是staff进入，页面会先渲染customer对应的页面结构，然后customer消失，再渲染staff对应的页面结构。
* 解决方案：1、data上，设置userType为''。2、onLod中设置userType为本地存储中的值，如果无值，则设置为'customer'。3、套模板的时候使用```wx:if="{{userType=='staff'}}"```和```wx:if="{{userType=='customer'}}"```，而不是使用```wx:else```。

# 视图渲染的时候让文本换行
* 微信小程序：```\n```
* html：```<br>```

# wx.request
> https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html
* 回调函数。
* 只要成功接收到服务器返回，无论 statusCode 是多少，都会进入 success 回调。请开发者根据业务逻辑对返回值进行判断。

# 机型兼容(兼容iPhone X) - 适配iphoneX的底部悬浮
```javascript
App({
  onLaunch () {
    // 机型兼容。
    wx.getSystemInfo({ // 机型兼容：'iPhone X'机型时 res.model的值包含'iPhone X' 距底差值是68rpx
      success: (res) => { // 虽是回调写法，但内部是同步处理。因下面两个console.log是按代码的先后顺序输出的。
        wx.setStorageSync('iPad', res.model.search('iPad') !== -1)
        wx.setStorageSync('iPhoneX', res.model.search('iPhone X') !== -1)
        // wx.setStorageSync('iPhoneX', true)
        // console.log('这里先执行了')
      }
    })
    // console.log('这里后执行了')
  }
})
```
```scss
$iPhoneXh: 34; // iPhone X 距底差值是68rpx

.iPhoneXb {
  bottom: $iPhoneXh * 1px !important; // iPhone X 距底差值是68rpx
}

.iPhoneXh {
  height: $iPhoneXh * 1px !important; // iPhone X 距底差值是68rpx
}

.iPhoneXpb {
  padding-bottom: $iPhoneXh * 1px !important; // iPhone X 距底差值是68rpx
}
```
* 怎么全局适配？
    - 1、制作一个悬浮的层，遮住底部的内容。
    - 2、制作一个在最底部的容器，用来占位置。防止拉到底部显示不全。
    - 3、如果遇到了其他悬浮层，则对悬浮层进行单独处理。
    - 注：需要兼容的点有很多。例如底部弹窗悬浮，底部悬浮按钮。
    - 建议：重要页面进行兼容即可。例如商品详情页兼容一下。如果要进行全站兼容的话，着实劳心伤神。

# 微信saveImageToPhotosAlbum下载图片报错
> 报错信息：```saveImageToPhotosAlbum:fail invalid file type```
* 原因：后台返回的数据是二进制数据流。微信的saveImageToPhotosAlbum方法识别不了。
    - 后端解决方案：后台返回客户端能直接识别成图片的```Content-Type: image/jpeg```即可。
    - 其他解决方案：把图片绘制到canvas上，再把canvas转成图片并保存。(没测试，理论上能成，因为之前canvas海报上的二维码也是二进制数据流格式，可以保存)。

# 微信小程序怎么实现后退事件的监听
* onUnload生命周期配合订阅发布模式即可。
* 应用场景：
    - 订单详情页面有个去评价的按钮。点了去评价就去评价了。评价完如果我点了回退。回到了订单详情页。这个去评价的按钮应该消失。
    - 但是我有不想使用onShow每次都打接口。我只想回退的时候再打接口。于是这个方式就可以用达成目的了。
    - 优化：评价完重定向(redirectTo)到评价详情页。可以防止回退到评价页进行二次评价。
    - 以下是评论详情页代码片段。
    ```javascript
    Page({
      onUnload () {
        Event.$emit('comment')
      } 
    })
    ```
    - 以下是订单详情页代码片段。
    ```javascript
    Page({
      onLoad () {
        Event.$on('comment', () => { // 页面如果没被销毁，再次navigateTo进入，会被再次绑定。
          if (!this.data.isTrigger) {
            this.getDetail();
            this.data.isTrigger = true;
            setTimeout(() => {
              this.data.isTrigger = false // 防止多次绑定，导致多次触发this.getDetail()。因开关变true是同步的变false是异步的所以可以防止。
            }, 500)
          }
        });
        this.getDetail()
      },
      onUnload () {
        Event.$off('comment')
      } 
    })
    ```

# 点击事件(bindtap)无效了？
* 父元素使用css写0.5px边框时用的伪元素配合定位加缩放，把子元素给覆盖住了。所以给子元素加事件无效。注意一下即可。

# import和include
* 文档：https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/import.html
* `include` 可以将目标文件除了 `<template/>` `<wxs/>` 外的整个代码引入，相当于是拷贝到 `include` 位置，如：
```
<!-- index.wxml -->
<include src="header.wxml"/>
<view> body </view>
<include src="footer.wxml"/>
```
* import可以在该文件中使用目标文件定义的template
> 定义时template上要有name属性，使用时template上要有is属性与之对应。
```
<!-- item.wxml -->
<template name="item">
  <text>{{text}}</text>
</template>
```
```
<import src="item.wxml"/>
<template is="item" data="{{text:'forbar'}}"/>
```
* import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。
    - 简而言之：被import的wxml文件中不要import别的wxml文件。
* template数据传递
    - 传递对象：`data="{{text:'forbar'}}"`
    - 传递数组：`data="{{['forbar']}}"`
    - 百度小程序需要使用三个大括号 `data="{{{text:'forbar'}}}"`和`data="{{{['forbar']}}}"`
    - 建议：统一传对象
        - 假设obj为一个对象：`var obj = {a:1,b:2}`。
        - 微信小程序：`data="{{obj}}"`。
        - 百度小程序：`data="{{{obj}}}"`。
        - 渲染时：直接`{{obj.a }}`。

# wx:for遍历对象和数组
* `<view wx:for="{{['a','b']}}" wx:for-item="item" wx:for-index="index" wx:key="{{item}}">{{item}}</view>`
* `<view wx:for="{{({a:'1',b:'2'})}}" wx:for-item="value" wx:for-index="index" wx:key="{{value}}">{{value}}</view>`
* 注：在试图层直接遍历对象字面量需要加`()`，否则会报错。数组则不需要。如果是变量，则更不需要。
    - 上述template的数据传递方式，不适用于此处。
* `wx:for-item="item"`和`wx:for-index="index"`可以省略，因此两项是默认值。
    - 遍历数组时，item对应value值。index对应索引值。
    - 遍历对象时，item对应value值。index对应键值。

# wx.createSelectorQuery().in(this)
* 注意：不要把wx.createSelectorQuery().in(this)定义成变量，供给多出使用，否则会出bug。
```
{
  // 商品详情文字不超过一行不显示展开按钮。
  adjustToggle (newVal) {
    clearTimeout(this.data.timerToggle)
    this.data.timerToggle = setTimeout(() => {
      // 注意：不要把wx.createSelectorQuery().in(this)定义成变量，供给多出使用，否则会出bug。
      const list = newVal
      let lineHeight = 18 // 这里18写死，就注定算不对，应是18乘以屏幕相对于375的缩放倍数才对。除非css里也写死像素。但是打包工具的px2rpx不允许css写死(会被转成rpx)。
      wx.createSelectorQuery().in(this).select('#line-height-placeholder').boundingClientRect((rect) => {
        lineHeight = rect.height // 此处是用以解决lineHeight固定18的问题。
      }).exec()
  
      list.forEach((item, index) => {
        wx.createSelectorQuery().in(this).select(`#goods-spec-${index}`).boundingClientRect((rect) => {
          console.log(index) // 如果把wx.createSelectorQuery().in(this)定义成变量，供给多出使用，则此处会被多次触发，且index是9次0-9，假设list.length是10。
          if (rect && rect.id === `goods-spec-${index}`) {
            list[index].unfold = false
            list[index].showToggle = rect.height > lineHeight
            if (index === list.length - 1) {
              console.log('index', index)
              this.setData({ listData: list })
            }
          }
        }).exec()
      })
    }, 200)
  }
}
```

# setData
* setData支持改变数组中的某一项或对象的某个属性，如```array[2].message，a.b.c.d```，并且不需要在```this.data```中预先定义。
```
this.setData({
  'array[0].text':'changed data'
})
this.setData({
  'object.text': 'changed data'
});
```

# scroll-view
* scroll-into-view="{{idName}}"
    - 滚动到内部对应id的位置
    - idName不能是纯数字
* scroll-with-animation
    - 滚动时有动画效果
* scroll-view的滚动，不会出现滚动条，建议使用scroll-view标签的滚动，而不是使用css的overflow:auto进行滚动。

# 监听路由变化
```
App({
  onLaunch (opts) {
    console.log('onLaunch', opts)
    wx.onAppRoute((route) => {
      console.log('onAppRoute', route)
    })
  }
})
```

# 脚本 - 使用脚本生成小程序页面
* 文档：https://github.com/cantonjs/create-wxapp-page
* 配置
```
"scripts": {
  "create-page": "create-wxapp-page --dir=src --json --indent=2 --style=scss --name",
  "create-component": "create-wxapp-page --dir=src --json --indent=2 --style=scss --type component --name"
}
```
* 根据上述配置，输入下面的命令，命令行里会让你输入文件名称的。
```
npm run create-page
```

# 脚本 - 使用脚本生成小程序页面标题集合
* 配置
```

"scripts": {
  "title": "node ./src/create.title.json.js"
}
```
* create.title.json.js代码如下：
```
const fs = require('fs')
const appJson = fs.readFileSync(`${__dirname}/app.json`, { encoding: 'utf-8' })
const objAppJson = JSON.parse(appJson)
const result = objAppJson.pages.map(v => {
  const obj = {
    path: v
  }
  const pageJson = fs.readFileSync(`${__dirname}/${v}.json`, { encoding: 'utf-8' })
  const objPageJson = JSON.parse(pageJson)
  obj.title = objPageJson.navigationBarTitleTextBak || objPageJson.navigationBarTitleText || ''
  return obj
})
fs.writeFileSync(`${__dirname}/title.json`, JSON.stringify(result), { encoding: 'utf-8' })
```

# 复制文本
* 小程序长按事件：```bindlongpress```。
* wxml：
```
<view>内容：{{contents}} </view>
<view  bindtap='copyText' data-text="{{contents}}">复制</view>
```
* js：
```
Page({
  data: {
    contents: '这是可以复制的文字,粘贴后即可看到效果'
  },
  copyText: function (e) {
    console.log(e)
    wx.setClipboardData({
      data: e.currentTarget.dataset.text,
      success: function (res) {
        wx.getClipboardData({
          success: function (res) {
            wx.showToast({
              title: '复制成功'
            })
          }
        })
      }
    })
  }
})
```
* 方案2：使用`text`标签，配合`selectable`属性即可触发微信自带的长按复制功能。

# tabBar
* app.json中 iconPath 不能使用远程图片，只能使用本地图片。本地图片可以反斜杠(`/`)开头。表示根目录。
* app.json中 pagePath 不能以反斜杠(`/`)开头。
* wx.setTabBarItem 动态设置 tabBar 某一项的内容，2.7.0 起图片支持临时文件和网络文件。

# 动态设置 tabBar 某一项的内容
> 不能修改路径。所以此接口没什么卵用。
```javascript
wx.setTabBarItem({
  index: 0,
  text: 'text',
  iconPath: '/path/to/iconPath',
  selectedIconPath: '/path/to/selectedIconPath'
})
```
https://developers.weixin.qq.com/miniprogram/dev/api/wx.setTabBarItem.html

# 系统自带tabBar的对应页面没有回退按钮
* 问题：系统自带的tabBar，对应页面没有回退按钮。
    - 系统自带的tabBar，只能使用wx.switchTab或wx.reLaunch进行跳转。
    - 因为使用wx.switchTab或wx.reLaunch时路由栈(后进先出)会被清理。清理后路由栈里只有当前页面的信息。
    - 故没有回退按钮。
* 解法1(自定义底部导航)：不使用系统的tabBar，使用自定义的tabBar。推荐用 fixed 在底部的 cover-view + cover-image 组件渲染样式，以保证 tabBar 层级相对较高。
    - 弊端：导航之间切换，会抖动。
* 解法2(自定义顶部导航)：自定义所有页面的顶部导航条，重写路由栈。如此需要把所有跳转改为js跳转，并对微信小程序的四种跳转方式进行二次封装，然后配合wx.onAppRoute，对路由栈进行增删改查。
    - 伪弊端：涉及到全站，工作量很大。
    
# navigationStyle自定义顶部导航栏
* page.json中增加`"navigationStyle": "custom"`字段。
* default：默认样式。
* custom：自定义导航栏，只保留右上角胶囊按钮。
```
// 自定义导航栏高适应性动态计算
wx.getSystemInfo({
  success: ({ model, statusBarHeight }) => {
    let totalTopHeight = 70
    if (~model.indexOf('iPhone X')) totalTopHeight = 88
    else if (~model.indexOf('iPhone')) totalTopHeight = 64

    this.globalData.statusBarHeight = statusBarHeight // 小程序状态栏高度(胶囊区域)
    this.globalData.titleBarHeight = totalTopHeight - statusBarHeight // 手机顶部状态栏高度(信号格区域)
  },
  fail: () => {
    this.globalData.statusBarHeight = 0 // 小程序状态栏高度(胶囊区域)
    this.globalData.titleBarHeight = 0 // 手机顶部状态栏高度(信号格区域)
  }
})
```
* 自定义顶部导航栏能全局配置么？
    - 能。在`app.json`的`window`属性里加上`"navigationStyle":"custom"`属性即可。

# 快速点击筛选，会筛选出重复的数据
* 原因是，接口并发了，虽然dataList清理了，但是接口是异步的。
* 解决方案：加开关，等接口返回，才允许下次点击。

# app.js中的onShow钩子和页面最顶部代码哪个先执行？
* app.js中的onShow钩子先执行且钩子中的同步代码执行完之后，页面最顶部代码才执行。
* app.js
```
App({
  onShow (opts) {
    console.log('onShow', opts) // 先执行
  }
})
```
* /pages/home/index.js
```
console.log('/pages/home/index.js') // 后执行
Page({})
```

# 微信小程序发送模板消息需要的formId
* 批量获取微信小程序的`formId`。
* wxml：需要多少个就套多少层(不嵌套不行，必须嵌套)。
```
<form report-submit='true' bindsubmit='getFormId'>
  <button form-type='submit'>
    <button form-type='submit'>
      button
    </button>
  </button>
</form>
```
* js：`getFormId`会被触发多次。
```
Page({
  getFormId (e) {
    console.log(e)
  }
})
```
* wxss：`button::after`的样式很重要，否则`getFormId`只会被触发1次。
```
button {
  margin: 0;
  padding: 0;
  border-radius: 0;
  background: none;
}

button::after {
  display: none; /* 加这个，button叠加会穿透，因为可以触发多次getFormId */
  border: none; /* 按钮去掉默认的边框 */
}
```
* 注：此方法已经被微信封掉了，已经不能用了。目前只能在需要发模板消息的地方，增加按钮，获取formId了。

# navigateTo跳自身页面可以么？
* 肯定可以啊，想想商详页的推荐商品不就明白了！跳入推荐商品的详情页，不就还是跳商详页么。

# 微信小程序授权规则改了
* 规范：https://developers.weixin.qq.com/community/operate/doc/000640bb8441b82900e89f48351401
> 摘要：不得在用户清楚知悉、了解小程序的功能之前，要求用户进行帐号登录。“帐号登录功能”是指开发者在小程序内提供帐号登录功能，包括但不限于进行的手机号登录，getuserinfo形式登录、邮箱登录等形式。
* 解决方案1(局部处理)：针对需要授权的地方，进行按钮处理。如果没授权，则跳授权页，如果授权了，才继续执行。
```
module.exports = {
  toAuthorization () { // 如果没头像或者没昵称则跳授权页
    if (!wx.getStorageSync('nickName') || !wx.getStorageSync('headUrl')) {
      const { fullPath } = getCurrentPage()
      wx.redirectTo({ url: `/pages/authorization/authorization?refererUrl=${encodeURIComponent(fullPath)}` })
      return true
    }
    return false
  }
}
```
* 解决方案2(全局处理)：利用onAppRoute配合白名单进行监听处理。
```
wx.onAppRoute((route) => {
  console.log('onAppRoute', route)
  // 如果没授权头像和昵称，则进行头像和昵称的授权。
  const pageIndex = [
    'pages/authorization/authorization', // 授权页不检测
    'pages/order-detail/order-detail', // 订单详情页不检测
    'pages/order-list/order-list', // 订单列表页不检测
    'pages/order-confirm/order-confirm', // 下单页不检测
    'pages/search-panel/search-panel', // 搜索面板页不检测
    'pages/search/search', // 搜索页不检测
    'pages/index/index', // 首页不检测
    'pages/category/category', // 分类页不检测
    'pages/explore/explore', // 发现页不检测
    'pages/cart/cart', // 购物车页不检测
    'pages/my/my' // 我的页面不检测
  ].indexOf(route.path)
  // 其他页面都检测
  if (pageIndex === -1) {
    // ⬇️方案1(全局处理)、此处的监听不会和登陆冲突。理下两种登陆流程(没token和token过期了)就能明白。
    // 登录的快慢和检测授权页并跳转无论谁快谁慢都没关系。
    // 登录快，则先跳当前页，后跳授权页。
    // 授权快，则先跳授权页，后再跳授权页(做了过滤，不会二次跳授权页)。
    // 在授权页点击授权完毕之后，则会跳回授权页上带的参数(refererUrl)页或首页。
    // 在授权页点击取消之后，则会跳回授权页上带的参数(refererUrl)页或首页。如果回到上个页面(refererUrl页)，检测到没满足条件会再次跳入授权页。
    // 为了防止重复跳入授权页，授权点取消，如果页面栈的长度大于等于2则回上个(实则是上上个，因redirectTo了)页面，否则直接回首页。并提示文案：确认要取消么？取消之后无法体验完整的小程序！注：跳授权页需使用redirectTo的方式。
    // 弊端：转发进来的，会直接跳入授权页，点了取消，无法回到之前的页面。如果小程序审核人员连转发也监控的话。则可能会审核不通过。
    // ⬇️方案2(局部处理)、针对页面按钮，单独处理。
    if (!wx.getStorageSync('nickName') || !wx.getStorageSync('headUrl')) {
      const { fullPath } = business.getCurrentPage()
      wx.redirectTo({ url: `/pages/authorization/authorization?refererUrl=${encodeURIComponent(fullPath)}` })
    }
  }
})
```
* 授权页js
```
Page({
  bindGetUserInfo ({ detail }) {
    const userInfo = detail.userInfo
    if (!userInfo) return
    ApiUser.edit({
      data: {
        headUrl: userInfo.avatarUrl,
        nickName: userInfo.nickName,
        gender: userInfo.gender,
        province: userInfo.province,
        city: userInfo.city,
        country: userInfo.country
      },
      success: () => {
        wx.setStorageSync('nickName', userInfo.nickName)
        wx.setStorageSync('headUrl', userInfo.avatarUrl)
        if (this.options.refererUrl) {
          wx[business.isTabBarUrl(this.options.refererUrl) ? 'reLaunch' : 'redirectTo']({ url: decodeURIComponent(this.options.refererUrl) })
          return
        }
        wx.reLaunch({ url: '/pages/index/index' })
      }
    })
  },
  cancel () {
    wx.showModal({
      title: '取消之后无法体验部分功能！',
      success: (res) => {
        if (res.confirm) {
          const { pages } = business.getCurrentPage()
          if (pages.length >= 2) {
            wx.navigateBack({ delta: 1 })
          } else {
            wx.reLaunch({ url: '/pages/index/index' })
          }
        }
      }
    })
  }
})
```
* 返回上一个页面：《问》会保留上个页面的入参么？《答》会，且不会触发上个页面的onLoad。即不会重载页面。switchTab也不会重载页面。
```wx.navigateBack({ delta: 1 })```

# 小程序分享卡片图的尺寸
* 5:4 600*480

# input上面覆盖一个清除输入框的按钮。会导致输入框清除不掉。
* 特性：键盘弹起状态，输入框里的值清除不掉。键盘收起状态，输入框里的值可以被清除掉。
* 解决方案：不让两者覆盖到一起。

# scene场景值
* https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html

# 组件内，监控小程序页面的生命周期
```
pageLifetimes: {
    // 组件所在页面的生命周期函数
    show: function () { },
    hide: function () { },
    resize: function () { }
}
```
* 组件中监听的`show`会先触发，页面上的`onShow`会后触发。

# 小程序引用图片可以用http://的链接吗
* 可以。但是如果要使用微信小程序的接口获取图片的话，则仅支持https://的且要配置了下载域名。

# 富文本清理不要的标签
> https://github.com/icindy/wxParse
* 不清理的话，wxParse会把script和style中的代码当成文本渲染出来。
* meta和link不会被当做文本渲染出来。但是没啥用，所以我就顺手清理掉了。
```
let str = res2.data.content.replace(/<script[^>]*>[\d\D]*?<\/script>/g, '') // 把代码中的标签script包括其中内容去掉
str = str.replace(/<style[^>]*>[\d\D]*?<\/style>/g, '') // 把代码中的标签style包括其中内容去掉
str = str.replace(/<meta[^>]*>[\d\D]*?/g, '')  // 把代码中的标签meta包括其中内容去掉
str = str.replace(/<link[^>]*>[\d\D]*?/g, '')  // 把代码中的标签link包括其中内容去掉
str = str.replace(/<title[^>]*>[\d\D]*?<\/title>/g, '')  // 把代码中的标签title包括其中内容去掉
str = str.replace(/<!--[\w\W\r\n]*?-->/g, '') // 把代码中的标签title包括其中内容去掉
str = str.replace(/id="activity-name"/g, 'id="activity-name" style="padding:0 10px;"') // 主标题样式处理(因都是微信公众号文章故可以如此匹配)
str = str.replace(/id="meta_content"/g, 'id="meta_content" style="padding:0 10px 10px;"') // 子标题样式处理(因都是微信公众号文章故可以如此匹配)
str = str.trim()
```
* 正则默认是贪婪匹配。上述加`?`表示非贪婪匹配。
* `*` 0个或1个或多个，相当于`{0,}`。
* `?` 0个或1个，相当于`{0,1}`。
* `+` 1个或多个，相当于`{1,}`。

# 微信小程序，测试阶段，发现某些机型不显示头像
* 问题原因：手机因抓包，开了代理。
* 解决方案：关闭代理即可。
