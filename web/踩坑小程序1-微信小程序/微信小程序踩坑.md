# 微信开发者工具
* 编译模式，定格在某一个页面时，启动参数设置成：?id=3549。导致一直报错
    - 解决方案，去掉问号(?)。

# 跳转
* wx.navigateTo
    - 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。
* wx.redirectTo
    - 关闭当前页面，跳转到应用内的某个页面。
* wx.reLaunch
    - 关闭所有页面，打开到应用内的某个页面。
* wx.switchTab
    - 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。

# 页面之间传值
* 方式1
```
// 在首页，使用api跳转到详情页
wx.navigateTo('/pages/detail/detail/?id=1');
// 在详情页页面中的onLoad方法中接收
Page({
    onLoad(query) {
        console.log('接收数据', query);
    },
});
```
* 方式2
```
// app.js里定义一个全局变量。
App({
    globalData: {},
});
// 跳转到别的页面的时候，可以更改这个值。
const app = getApp();
app.globalData.key1 = 'value1';
// 在其他页面就可以拿到这个值了。
const app = getApp();
console.log('数据', app.globalData.key1);
```
* 方式3
```
// 通过本地存储，跳转页面之前设置一个值。
wx.setStorage('key1', 'value1'); // 异步的
wx.setStorageSync('key1', 'value1'); // 同步的
// 到另外一个页面时，再接收这个值。
wx.getStorage('key1', 'value1'); // 异步的
wx.getStorageSync('key1', 'value1'); // 同步的
```

# 事件传参
```
// wxml
<view bindtap="fnClick" data-id="123"></view>
// js
Page({
    fnClick(ev) {
        console.log('数据', ev.currentTarget.dataset.id);
    },
});
```

# WebStorm 格式化
* WebStorm 格式化wxss文件时，导致数值和单位之间有空格，正常应该是20rpx，编辑器格式化成了20 rpx导致无效。
    - 解决方案，不格式化，或者使用sass工具，封装个函数去转义。
    ```
    @function px2rpx($px) {
      @return $px * 1rpx;
    }
    ```

# 针对某一个页面进行下拉刷新
* index.json里加上window:{enablePullDownRefresh:true}，下拉刷新无效。
    - 解决方案：需要注意的是在需要下拉刷新的页面设置json时，直接写enablePullDownRefresh属性就行了，不需要写window。
* 下拉刷新，重新执行onLoad，组件内部数据没更新。
    - 解决方案：先把数据变成空，然后再重新赋值。然后关闭下拉刷新。wx.stopPullDownRefresh();
    - 新坑：重新执行onLoad()，导致onLoad(options){}函数中，options变为了undefined。
    - 新坑解决方案：把options存在data上，刷新时把数据带过去即可```this.onLoad(this.data.options)```。
* 下拉刷新时(正常思维)，data上除去options的其他数据都设置成默认状态。然后重新执行```this.onLoad(this.data.options)```。
    - 有定时器要清理掉定时器。
    - 有分页数据则要重置为默认数据。
    - 有列表数据则要重置为空。
* 下拉刷新时(这样也行)，data上全都默认为null。或者data上不设置数据(经过测试，只要使用setData设置上的数据即可渲染到视图层，即data上没必要设置上数据的默认值)。
    - 在onLoad的时候使用```this.setData```设置所有数据的默认值(可提取成一个方法，名字我都想好了就叫setDefaultData)。注：如果有定时器要先清理一下定时器(在设置默认数据之前)。
    - 下拉刷新的时候重新执行```this.onLoad(this.data.options)```。
* 下拉刷新时(建议如此)，定一个默认数据模型方法(方法可以防止对象引用，名字我都想好了就叫getDefaultData)，方法中返回一个对象。然后给data赋值默认值的时候调用这个方法即可。
```javascript
const ApiGroup = require('../../api/group.js')

function getDefaultData (options) {
  const obj = { // 默认值
    resData: {},
    options: {}
  }
  if (options) { // 根据options重置默认值
    obj.options = options
  }
  return obj
}

Page({
  data: getDefaultData(),

  onLoad (options) {
    this.setData(getDefaultData(options))
    ApiGroup.info({
      data: {
        groupId: options.groupId
      },
      success: (res) => {
        this.setData({ resData: res.data })
      }
    })
  },

  onPullDownRefresh () {
    this.onLoad(this.data.options)
    wx.stopPullDownRefresh()
  },

  returnPrevPage () {
    wx.navigateBack({
      delta: 1
    })
  }
})
```

# 分页
* 页码自增如果放在请求完成之后。
    - 则需要判断当前在否在加载中？加载中不允许继续请求(必须判定，否则多次拉到底部会重复请求同一页码数据)。
    - 加载之前判断当前页码是否已超总页码？超出不允许请求。
* 页码自增如果放在请求之前。
    - 则需要判断当前在否在加载中？加载中不允许继续请求(非必须判定，多次拉到底部页码会自增)(建议判定，否则可能会出现后请求的先给了响应以至于顺序错乱)(如果想偷懒，可以不判定，但是会留下这个隐藏bug哟)。
    - 加载之前判断当前页码是否已超总页码？超出不允许请求。

# canvas组件
* canvas-id属性如果不加，canvas组件会一直是display:none。
    - 注意：不是id属性，是canvas-id属性。
* canvas 让px可以自适应，原理就是等比缩放。
```
function px2remCanvas(px) {
    return px * wx.getSystemInfoSync().windowWidth / 375; // 设计图是375的。
}
```
* canvas转图片时：1、canvas里用wx.drawImage插入的图片，真机本地预览进行测试，发现图片不显示。2、导出的图片变形了。3、导出的图片没有背景色。
    - 1、解决方案之wx.drawImage插入的图片，真机本地预览进行测试，发现图片不显示：
        - 1、图片需要是本地图片。
        - 2、不支持svg格式。
        - 3-1、远程图片需要下载到本地 可以使用wx.downloadFile方法或者wx.getImageInfo方法。
        - 3-2、远程图片仅支持https协议的图片。
        - 3-3、开发者工具，预览时用真机是无效的，预览开启调试模式时真机是有效的，远程调试时用真机是有效的。
        - 3-4、调试模式，不校验域名。导致真机上wx.drawImage无效的原因是，网络图片的链接不在小程序的信任列表中，需要管理员去后台把链接加入白名单。
        - 3-5、downloadFile，需要在小程序公众后台配置相应的downloadFile域名，否则会无法正常使用。
    - 2、解决问题之宽高不对：
        - 1、因为wx.canvasToTempFilePath方法导出的图片默认宽高是小程序去掉顶部菜单的宽高（如果画布的宽高不是这个比例，则导出的图片会变形），应该设置成画布的宽高乘以对应的倍数，先3倍吧。
        - 2、然后再配合wx.saveImageToPhotosAlbum方法进行导出。
    - 3、解决方案之背景色无效：因为我使用的是css的背景色，所以无效，背景色应该也要使用canvas绘画出来。
* canvas海报太慢了。
    - 解决方案：下载一次就存储起来，把原url也存储起来。如果原url更新了（图片更新了），就重新下载并存储。
    - 如果还觉的慢，就在前一个页面进行提前下载并存储，让用户无感知。然后来到当前页时，判断，如果前一个页面已经把图片下载好了，就直接使用，否则当前页进行重新下载并存储。
    - 注意事项：如果你是判断存储的已经有了，就直接使用存储的。那么你就需要去注意后续的数据更新，例如海报图片更换了，你就要重新生成最新的海报。
* 如果使用v-if控制canvas，下次显示时，会导致绘画无效，原因没有排查。建议使用display:none和display:block控制canvas的显示隐藏。
* font
    - 微信小程序中，font属性对应的值里，如果fontSize带小数，会导致设置失败，变成默认的10px sans-serif。浏览器中无这种问题。
    - 解决方案：向下取整。向上取整。四舍五入。
* 微信小程序中，canvas绘画时，在代码最后，代码最后，代码最后要执行一次ctx.draw();方法。绘制的才有效果。
* clip路径裁切，如果在save和restore之间，可以直接裁切，不用担心后面被影响，如果不是的话。建议fill填充一下，否则后续别的路径填充如果影响到了，会导致覆盖掉填充的图片（微信小程序模拟器上才有这个坑）。真机测试不fill一下，也是可行的。
* ctx.scale真机上导致多次缩放。
    - h5的canvas使用save和restore可以解决这种问题。
    - 微信开发者工具的模拟器上没有这种问题。
    - 真机上难道只能内部处理坐标么？是的，真机上我目前的解决方案是，内部坐标封装函数进行缩放处理。
    ```
    const px2remCanvas = function (px) { // canvas自适应
        return px * wx.getSystemInfoSync().windowWidth / 375; // 设计图是375的。
    };
    const px2px = function (px) { // canvas缩放
        return px2remCanvas(px) * scale; // scale是canvas的缩放比例。
    };
    ```

# webview组件
* webview内h5页面回跳小程序，直接运行js回跳无效。
    - 解决方案：加定时器。
    ```
    setTimeout(function () {
        // 此处运行js，跳回小程序，不加定时器回跳无效。原因不知，解决方案是我猜出来的。
    }, 60);
    ```
* webview内部不能调起微信支付。
    - 解决方案：webview中下完单之后，带着订单号回跳到小程序端。然后用订单号去打后端接口获取支付需要的数据，然后再拿这些数据去调起小程序端的支付。

# 页面转发
* 如果Page上配置的有onShareAppMessage方法，右上角菜单就可以有转发功能，当然，不想有转发功能，去掉就行了。例如分销员页面，有些人开启了，有些人没开启，所以就不能有转发，否则需要判断跳转。
* 在return的对象{}中，加上success回调，即可监听到转发成功。
* 配置了onShareAppMessage方法之后怎么禁止掉右上角的转发？
    - 解决方案：在页面监听事件的onLoad事件中，直接触发wx.hideShareMenu();即可屏蔽右上角的转发。
* 分享转发的网络图片，域名也需要在小程序管理后台的下载域名列表里添加了才可以转发出去。

# getStorageSync
* ```wx.getStorageSync('distributor_id')```。如果在data时就赋值获取或者直接值赋给一个变量，在某些机型会丢值。真是见了鬼了，这根本无解好吧，原因不明。
    - 我怀疑是SDK版本问题。因时间原因（通宵上线，先保障功能正常，不能浪费大家的时间），不能在有问题的机器上进行测试。
    - 解决方案：哪里需要就直接获取```wx.getStorageSync('distributor_id')```。当然同事也更换了版本(2.2.2 -> 2.2.5)。因两者是同时进行，所以到底是这么解决的，有待考察。
    - 我本地用的2.0.4版本，未发现异常。不使用变量赋值之后，同事将SDK切回2.2.2版本，发现也可以获取到数据了，可是这让人无法理解啊。虽然事实摆在眼前，但是我个人仍然感觉是SDK版本有问题的可能性更高一点。

# bindblur
* 真机测试：输入完毕点击按钮的一瞬间是空值。
    - 解决方案1：使用bindinput代替bindblur。
    - 解决方案2：点击之后，延迟一下，个人不喜欢这种方式。

# onShow
* 因为使用onShow，data上的数据，不会每次都初始化。例如默认isShow1是false。isShow2是false。满足条件则变为true。
    - 第一次进来时，满足条件我让isShow1变成了true。
    - 第二次进来时，满足条件我让isShow2变成了true。但是我还要isShow1变成默认的false。
        - 此时，data上的数据是不会自动初始化把isShow1变成false的。
        - 需要手动把isShow1和isShow2变成false，然后继续打接口判断，满足条件让对应的变成true。
* 总结：onShow不会初始化data上的数据，如果需要初始化，则需要手动处理。

# 回退，数据不更新，还是老数据
* 解决方案：onShow里调this.onLoad();但是这样做，有问题，因为初始访问会同时调用onLoad和onShow，所以正确解法是：使用onShow代替onLoad即可。
* 如果onload里有options，把options存到data上，然后调用this.onLoad(this.data.options);
* onShow不会更新data上的数据，有些状态如果需要初始化，则需要手动进行初始化。特别是一些按钮默认隐藏，后续触发了显示，可能就一直显示了。需要在onShow时，全部重置成不显示的。

# button组件去掉默认边框和圆角
* button组件上的边框和圆角是写在伪元素after上的，所以要对伪元素after处理才行。

# wx.login 和 wx.getUserInfo 以及获取手机号和获取openid
* wx.login可以用来获取临时登录凭证code，然后使用这个凭证code可以获取session_key 和 openid 等。
* wx.getUserInfo授权之后才能使用。```<button open-type="getUserInfo" bindgetuserinfo="bindGetUserInfo">点击进行授权登录</button>```
* 获取openid：
```
getOpenId(callback) {
  const that = this;
  const openId = wx.getStorageSync('open_id');
  if (openId) {
    callback(openId);
  } else {
    wx.login({
      success({ code }) {
        const userInfo = wx.getStorageSync('userInfo'); // 此处建议使用wx.getUserInfo。且建议不缓存。否则后续更新是个问题（后续需要更新的数据，都不建议进行长期存储）。
        that.ajax({
          url: 'wechat/getOpenId',
          data: { code, ...userInfo },
          isOpenId: true,
          success({ data }) {
            if (data.res === 'succ') {
              const result = data.result || {};
              userInfo.tel = result.tel || '';
              wx.setStorageSync('userInfo', userInfo);
              wx.setStorageSync('open_id', result.openid);
              wx.setStorageSync('session_key', result.session_key);
              callback(result.openid);
            }
          },
        });
      },
    });
  }
}
```
* 获取手机号：```<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber">授权手机号</button>```
```
getPhoneNumber(e) {
  const that = this;
  if (e.detail.errMsg === 'getPhoneNumber:ok') {
    ApiWechat.getPhone({
      data: {
        iv: e.detail.iv,
        encryptedData: e.detail.encryptedData,
      },
      callback(res) {
        if (res.phoneNumber) {
          that.setData({ show: false });
          app.globalData.userInfo.tel = res.phoneNumber;
          that.setMsg();
        }
      },
    });
  }
}
```

# App有onLaunch没有onLoad
* Page有onLoad没有onLaunch
* App和Page都有onShow和onHide

# 函数封装
* 源码：https://github.com/zhouhuafei/zhf.canvas-api/blob/master/src/index.js
* 功能：绘制多行文字，绘制圆角矩形等。

# 其他1
* 微信小程序中是没有Image，document，window等BOM和DOM对象的。

# rpx
* 750设计图 1rpx等于1px。
    - 单位要写成rpx。
* 375设计图 1rpx等于0.5px。1px等于2rpx。
    - 375设计图，量取的单位是10px，则要写成20rpx。建议使用scss处理。
* 如果你直接使用px作为单位，则微信会把1px转成2rpx。（注意，注意，注意，其实这里不是微信转的，是工具postcss转的。所以这里的总结是错误的。）
    - 个人觉的这里是为了兼容某些手机端ui框架，因大多数手机端ui框架都是使用的px。
    - px单位的ui组件可以使用postcss转成rem的。

# swiper和canvas
* 内嵌能在可视区展示的canvas组件会导致卡顿。
* 如果内部想展示，使用image组件展示即可。把canvas转成base64形式的数据，然后赋值给图片的src，即可展示出来。
* 可使用npm上的upng-js包模块的encode方法配合wx.arrayBufferToBase64方法实现功能。
* 坑点：canvasGetImageData需要在canvas绘画完毕之后进行获取。否则会是空的。draw的回调中还是需要定时器配合，否则获取还是为空，这可能是个bug。
```
// 绘制海报1
drawGoodsPoster1(v, v.scale, () => {
  setTimeout(() => {
    const w = Math.floor(v.width * getCanvasRatio()); // 因canvas自适应，这里要处理一下，此处得到的是自适应之后canvas的宽。
    const h = Math.floor(v.height * getCanvasRatio()); // 因canvas自适应，这里要处理一下，此处得到的是自适应之后canvas的宽。
    wx.canvasGetImageData({
      canvasId: v.id,
      x: 0,
      y: 0,
      width: w,
      height: h,
      success(res) {
        const arrayBuffer = upng.encode([res.data.buffer], w, h); // 转成utf-8数据
        v.imageBase64 = `data:image/png;base64,${wx.arrayBufferToBase64(arrayBuffer)}`;
        self.setData({ canvasSave });
        console.log(`canvasGetImageData${i}：`, res, arrayBuffer, v.imageBase64, getCanvasRatio(), v.width, v.height, w, h);
      },
    });
  }, 500);
});
```
* wx.canvasGetImageData在性能不好的机器上连续调用两次，即使使用了定时器延迟，也是会fail，所以以上方法行不通。
    - 使用wx.canvasToTempFilePath返回url直接给image组件使用即可。没必要使用base64。
* wx.canvasToTempFilePath报错：```canvasToTempFilePath:fail:create bitmap failed```
    - 原因：canvas元素不存在。应该在v-if满足条件的时候进行绘制。或者使用class控制显示隐藏。
* canvas层级太高，覆盖了底部导航。
    - 解决方案：使用cover-view标签重写底部导航。cover-view标签的使用限制请看文档：
    - https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html
    - 注意事项：仅支持最外层的cover-view标签使用```position: fixed```。
* swiper来回抖动
    - 问题重现：小程序切到后台，过段时间再切回前台就会如此。
    - 原因：因使用this.setData修改了swiper上的current属性导致的。
    - 官方解释：如果在 bindchange 的事件回调函数中使用 setData 改变 current 值，则有可能导致 setData 被不停地调用。
    - 解决方案：不要修改swiper上的current属性，如果需要使用索引，可定义一个变量在bindchange中接收索引。

# 其他2
* 获取用户信息失败，说明没授权登录，或者授权登录失效。
    - 需要把用来判断是否登录的字段移除掉。以保证可以再次跳到授权页面。
    ```
    wx.getUserInfo({
        success: (res) => {
        },
        fail: (err) => {
            console.log(err);
            wx.removeStorageSync('isLogin'); // 获取用户信息失败，说明没授权登录，或者授权登录失效。移掉此项，后续判断是否登录就通不过了，可以避免不必要的bug。
        },
    });
    ```

* 有open_id就算是登陆了。但是如果获取不到userInfo或者授权过期导致获取失败也是问题。
    - 所以正确逻辑应该是有open_id以及userInfo才算登录。
    - 封装login方法，在里面获取open_id以及userInfo。获取open_id成功则存储起来，获取userInfo成功则存一个hasUserInfo:true。因open_id不会变动，userInfo会变动，会变的都不建议存储起来。
    - 封装isLogin方法，在storage中检测到open_id以及hasUserInfo就算是登陆了。
    - 处理wx.getUserInfo方法。如果获取用户信息失败(如果失败原因是用户未授权)，就移掉关键字段open_id或者hasUserInfo(让isLogin方法通不过)，并跳转到授权登录页进行登录。

* project.config.json应该添加到git的版本库。
    - 如果不同的线对应着不同的品牌小程序，例如微好店小程序和微商城小程序，代码相同，appid不同。
    - 如果不在git的版本库里，做项目的时候，一切线，appid没变化，就会有问题。如此情况就只能曲线救国，例如用git再拉一份代码进行配置。
    - 如果在git的版本库里，就不会出现上面这种狗血的问题。

# css
* 不支持```*```号匹配。
* 不支持```.div > :nth-child(n){}```。
* 不支持使用本地背景图片。

# css3
* css3之sticky悬浮导航(存在兼容性问题，小程序中可以使用)。
    - 滚动到class为sticky的标签时，标签会自动悬浮。
    - 如果top为100px，则滚动到标签top距离顶部100px的位置时就悬浮。
    ```
    .sticky {
      position: -webkit-sticky;
      position: sticky;
      top: 0;
      z-index: 9999;
      background: #ff0000;
    }
    ```

# wx.chooseImage
* count为1在模拟器上测试时是正常的。
* count大与1时，例如为2，依然可以选择超过2张图片。
    - 虽然选择的图片个数超过了2个，但是接口的个数依然是2个，所以这不算是个大坑。

# 定时器
* 页面卸载(onUnload)要清理掉定时器，否则会导致报错（以前会导致报错）。如果不清理掉，定时器会一直走着。
    - onHide时也要清理掉。否则后续如果通过navigateTo又跳了进来，内存里则有两条定时器在走着，因为navigateTo不会触发onUnload。
* 如果使用navigateTo跳转则不用清理定时器，因为可以回退。
* 如果使用redirectTo跳转则建议清理掉定时器，因为无需回退。
* 总结：定时器如果不清理则会一直在内存中执行。
    - 举一反一：vue-router后退会触发vue的created和mounted钩子。即：后退会重新请求数据等。所以如果页面有定时器的话，应该在destroyed钩子清理掉。

# 在小程序中设置了数据setData，在插件中居然拿不到值？
* 原因：代码放在了Page构造器的上面。
* 解决方案：把getData放到onLoad钩子中即可。
* 传值的原理：其实就是修改模块中定义好的值(类似闭包)。

# 在小程序中明明可以直接分享插件内页，为什么非要做个share中转页？
* 因为智障。
    - 不仅仅是因为智障。如果跳入插件页需要带参数进去。可以在外部落地页进行统一处理。
* 插件应该是一个独立的第三方服务，外部只需要传入appid。
* 插件内部根据appid和open_id进行用户识别。

# 组件中使用字体图标
* 方案1：在组件中引入字体图标。
* 方案2：在使用组件的页面中引入字体图标。

# 二维码
* getWXACodeUnlimit 小程序生成二维码报错
* 41030	所传page页面不存在，或者小程序没有发布

# 小程序插件瘦身
* 公用样式和字体使用wxss文件。建议都使用wxss文件。因为scss会把import的文件杂糅到页面中(即使是wxss文件)。
* 如果非要使用scss。则建议把import```/*import 'xxx.wxss'*/;```的部分注释掉。当把scss转成wxss之后，再使用```gulp-batch-replace```替换掉注释。
    - 引入的时候引入注释版本的wxss。
    ```
    /*@import "/scss/iconfont.wxss";*/
    /*@import "/scss/common.wxss";*/
    ```
    - 打包的时候把指定的scss文件转成wxss文件。然后再把wxss文件中被注释的@import部分释放掉。
    - 最优解：使用微信原生的wxss文件。因为使用原生wxss互相引用(@import)的话不会导致内容增加。
    - 最优解难点在于如何配合scss使用。
        - 我个人建议生成一个公用的common.wxss样式文件。```common.scss -> common.wxss```
        - 然后内部引入iconfont.wxss文件。```iconfont.scss -> iconfont.wxss```
        - 其他页面全部都引入common.wxss文件即可。
        - gulp dev-wxss dev-scss 都要处理。
* 压缩js。
* 不要使用很大的第三方工具包。
* 不要压缩css或者使用正确的包去压缩css：因使用gulp-clean-css会把import的wxss文件中的内容杂糅到页面中。所以我个人不建议你去使用gulp-clean-css压缩css。
```
// 此处省略部分
gulp.task(`dev-scss`, function () {
  return gulp.src(['src/**/*.scss'])
    .pipe(plumber())
    .pipe(sass())
    .pipe(rename((path) => {
      path.extname = '.wxss';
    }))
    .pipe(px2rpx({
      screenWidth: 375, // 设计稿屏幕, 默认375
      wxappScreenWidth: 750, // 微信小程序屏幕, 默认750
      remPrecision: 6, // 小数精度, 默认6
    }))
    .pipe(replace([
      ['/*@import "../../scss/_iconfont.wxss";*/', '@import "../../scss/_iconfont.wxss";'],
      ['/*@import "../../scss/_reset.wxss";*/', '@import "../../scss/_reset.wxss";'],
    ]))
    .pipe(gulp.dest(`dist/`));
});
const uglifyes = require('uglify-es');
const uglify = require('gulp-uglify/composer')(uglifyes, console);
gulp.task(`dev-js`, function () {
  return gulp.src('src/**/*.js')
    .pipe(plumber())
    .pipe(uglify({
      ecma: 8,
      output: {
        // 最紧凑的输出
        beautify: false,
      },
      compress: {
        // 删除所有的 `console` 语句
        drop_console: isProduction,
      },
    }))
    .pipe(gulp.dest(`dist/`));
});
```

# 小程序怎么写转插件才会方便一点？
* 1、不要往```全局对象app```上绑定方法。因为插件中不能使用```getApp()```方法。
* 2、引入组件使用相对路径。
    - 因在插件中如果使用绝对路径需要带上/插件appid/xxx/yyy/。
    - 如果后续不做成插件，那么组件肯定是引入绝对路径更好用。

# 全局组件
* 组件的引入放到app.json的usingComponents属性上即可全局使用此组件。
    - 在其他组件中亦可直接使用。
    
# 插件
* ```<web-view />```不能插件中使用。

# 类似3D轮播图的实现原理
* 使用小程序自带的swiper组件。
* circular：是否无缝滚动。
* previous-margin：与上一张图片的间距。
* next-margin：与下一张图片的间距。
* 然后再设置非当前图片的层级和透明度以及高度。

# 修改placeholder样式
* ```placeholder-class="placeholder"```。

# 输入框placeholder文字抖动
* 官方的也抖。

# 垂直居中时某些机型 display: flex; align-items: center 对不齐
* 是因为高度和行高不一致导致的。
* 建议：给设置了flex居中的元素加高度加行高。否则有些机型会对不齐。微信开发者工具体现出来的就是如此。
* 单个英文字母偏下，例如：g、s。
    - 无解。

# 使用flex让价格底部对齐，结果字体大的价格有些偏上。
* 大的价格行高调整为零点几即可。

# onReachBottomDistance
* 单位是px。是相对手机屏幕宽度的。不是相对于750的。所以配这个值的时候要相对的写大一点。
* 在app.json中要配置到window属性里(页面上的属性如果要全局配置到app.json中，则都要配置到window属性里)。

# canvas图片宽度自适应
* ```wx.getImageInfo```可以获取图片的宽、高、类型、拍照方向、本地路径。
    - 获取图片信息。网络图片需先配置download域名才能生效。

# 获取组件距离顶部的距离以及滚动到指定距离
```javascript
// 创建节点选择器
const query = wx.createSelectorQuery();
// 选择id
query.select('#the-id').boundingClientRect();
query.selectViewport().scrollOffset();
query.exec(function (res) {
  console.log(res[0].top); // #the-id节点的上边界坐标
  console.log(res[1].scrollTop); // 显示区域的竖直滚动位置
  wx.pageScrollTo({
    scrollTop: 0,
  });
});
```

# 组件中选择器的应用
* 在组件中建议只使用class选择器，否则会抛错：```Some selectors are not allowed in component wxss, including tag name selectors, ID selectors, and attribute selectors```

# 下拉加载更多
> 暂无数据 没有更多数据 加载中
* 我之前封装这个组件，做了太多没意义的动作，例如监听properties中result的值，然后改变isShowLoading的值等。其实根本没必要。
* 直接拿properties中result提供的值进行套模板即可。result中提供的有当前页数，总页数，当前页数据条数，总数据条数。

# 组件构造器上的externalClasses属性和options.styleIsolation属性
* externalClasses很有局限性，无法覆盖组件内已有样式。
* options.styleIsolation设置为apply-shared可以在页面上覆盖子组件样式。

# 动态设置 tabBar 某一项的内容
> 不能修改路径。所以此接口没什么卵用。
```javascript
wx.setTabBarItem({
  index: 0,
  text: 'text',
  iconPath: '/path/to/iconPath',
  selectedIconPath: '/path/to/selectedIconPath'
})
```
https://developers.weixin.qq.com/miniprogram/dev/api/wx.setTabBarItem.html

# navigator踩坑
* 问题1：互相嵌套某些机型会穿透。
* 问题2: 在标签中使用bindtap会冒泡。
* 解决方案：使用```catchtap```。
    - 给标签直接加一个```catchtap```属性即可阻止默认行为。如果需要执行一些操作，可以```catchtap="fnName"```。
* 其他
    - 网页上a标签不能嵌套a标签。
        - 但是a标签可以套div。
        - a套div，div再套a，也是不行的。```<a href=""><div><a href=""></a></div></a>```会变成如下：
        ```html
        <a href=""></a>
        <div>
          <a href=""></a>
          <a href=""></a>
        </div>
        ```
        - p标签不可以套h1-h6不可以套div等其他块元素。```<p><h2></h2></p>```会变成如下：
        ```html
        <p></p>
        <h2></h2>
        <p></p>
        ```
        - 大多数情形下，内敛标签不允许嵌套块级标签。
    - 网页上使用定位让两个a标签重叠。点击a标签的时候，是不会穿透的。
    
# 登录统一处理
* 发送请求之前先检测有没有登录，没登录则调登录方法进行登录处理。
* 打接口如果提示登录过期了，则重新调用登录方法。
* 需要注意的是，如果当前正在登录，则不重复登录。定一个全局变量监控即可。

# 页面渲染时怎么防止wx:if抖动？
* 场景描述：userType有两个值staff和customer。判断使用wx:if="{{userType=='staff'}}"和wx:else判定。data上userType默认值是customer。onLoad中```this.setData({ userType: wx.getStorageSync('userType') || 'customer' })```。
* 问题描述：如果类型是staff进入，页面会先渲染customer对应的页面结构，然后customer消失，再渲染staff对应的页面结构。
* 解决方案：1、data上，设置userType为''。2、onLod中设置userType为本地存储中的值，如果无值，则设置为'customer'。3、套模板的时候使用```wx:if="{{userType=='staff'}}"```和```wx:if="{{userType=='customer'}}"```，而不是使用```wx:else```。
