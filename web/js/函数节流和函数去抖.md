
# 函数节流(throttle)
* 是让一个函数无法在很短的时间间隔内连续调用，当上一次函数执行后过了规定的时间间隔，才能进行下一次该函数的调用。
    - 如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。
    - 也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。
    - 实现原理：```new Date();```

# 函数去抖(debounce)
* 让一个函数在一定间隔内没有被调用时，才开始执行被调用方法。
    - 如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。
    - 也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。
    - 实现原理：```setTimeout();```

# 库1
* https://github.com/niksy/throttle-debounce#readme
> 函数节流：throttle(delay, noTrailing, callback, debounceMode)

> 函数去抖：debounce(delay, atBegin, callback)

# 库2
* https://lodash.com/docs/4.17.11#throttle

> 函数节流：_.throttle(func, [wait=0], [options={}])
* func （功能）：节流功能。
* [wait=0] （number）：限制调用的毫秒数。
* [options={}] （对象）：选项对象。
* [options.leading=true] （布尔值）：指定超时前沿的调用。
* [options.trailing=true] （布尔值）：指定在超时的后沿调用。
* 默认超时前沿和超时后沿都会调用一次。所以如果wait是300。则每隔300毫秒就调用两次。打印出两个123。如下：
```
var fn = _.throttle(function () {
  console.log(123);
}, 300, {trailing: true, leading: true});
fn();
fn();
```
* 如果只想打印出一个123，则需要把trailing或者leading中的一个设置为false。

> 函数去抖：_.debounce(func, [wait=0], [options={}])
* func （功能）：去抖动的功能。
* [wait=0] （number）：延迟的毫秒数。
* [options={}] （对象）：选项对象。
* [options.leading=false] （布尔值）：指定超时前沿的调用。
* [options.maxWait] （数字）：func允许在调用之前延迟最长时间。
* [options.trailing=true] （布尔值）：指定在超时的后沿调用。
