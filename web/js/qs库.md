* qs库
    - 可以序列化对象和数组。
    - 序列化时是深度序列化的。会把对象和数组中的内容全部转成字符串。
    - 序列化时，会忽略：空数组，空对象，undefined。
    - 序列化时，会把null转成空字符串。
    ```javascript
    var qs = require('qs');
    qs.stringify({a: []}); // ''
    qs.stringify({a: {}}); // ''
    qs.stringify({a: [{}]}); // ''
    qs.stringify({a: {b: []}}); // ''
    qs.stringify({a: {b: {}}}); // ''
    ```

* qs库踩坑：
    - 数组里如果超过21条json数据```[{a:1},{a:1}]```。
    - stringify之后再parse会导致数组变成json对象。
    - 解决方案：parse时有第二参数可以控制```{arrayLimit:9999}```。

* qs建议
    - 使用```Content-Type: application/json```请求数据时。
    - 因表单元素会把数字类型的数据全都处理成字符串。
    - 如果后端要数字类型的数据，我们则要把这些表单数据在提交前处理成数字。
    - 还要注意，不能把空字符串处理成0，否则编辑时，我本来没填值的输入框，结果值却变成了0。
    - 所以我个人建议，前端提交数据的时候，使用qs对数据进行序列化和反序列化。如此可以保证后端接收到的数据全都是字符串。
    - 处理完之后，非空数组和非空对象是内部值全都会变成字符串。但是空数组和空对象会被忽略(变成undefined)。
    - 建议1：所以我个人只建议在请求的时候对数据进行序列化和反序列化。
    - 如果响应的时候也对数据进行序列化和反序列化。则要对空数组和空对象进行兼容(空数组和空对象会被忽略以至于变成undefined)。
    - 建议2：使用```Content-Type: application/x-www-form-urlencoded```请求数据。
    - 这种格式下传输，后端接收到的数据全是字符串。
    - 其他：发送请求时，其实传输的数据全是字符串。application/json也不例外。也是通过字符串的形式传输过去的(json格式的字符串)。只不过能被后端框架解析成json对象罢了。
