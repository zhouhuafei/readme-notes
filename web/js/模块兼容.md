# 模块兼容
* 兼容commonjs规范 nodeJs
* 兼容amd规范 requireJs
* 兼容browser规范 window
```
"use strict";
(function (global, factory) {
    if (typeof exports === 'object' && typeof module !== 'undefined') { // nodejs - commonjs canon
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) { // requirejs - amd canon
        define(factory);
    } else { // window - browser canon
        global.moduleCompat = factory();
    }
})(this, function () {
    function moduleCompat() {
        console.log('moduleCompat');
    }

    return moduleCompat;
});
```
* 不能封装成方法使用1.因为module只针对当前文件有效,和函数在哪调用无关
* 不能封装成方法使用2.不能通过传参,因为module,define存在未定义情况,会报错
* 不能配合babel进行打包使用,他会把上面的this转成undefined
# Q&A
* 本来我是这么写的,但是严格模式不认下面这个this,因为严格模式下,函数自执行this是undefined
```
"use strict";
(function (name, factory) {
    if (typeof exports === 'object' && typeof module !== 'undefined') { // nodejs - commonjs canon
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) { // requirejs - amd canon
        define(factory);
    } else if (window) { // window - browser canon
        this[name] = factory();
    }
})('moduleCompat', function () {
    function moduleCompat() {
        console.log('moduleCompat');
    }

    return moduleCompat;
});
```
# 终极解决方案 - 使用下面这个babel转义和严格模式的问题都可以解决
```
"use strict";
(function (name, factory) {
    if (typeof exports === 'object' && typeof module !== 'undefined') { // nodejs - commonjs canon
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) { // requirejs - amd canon
        define(factory);
    } else { // window - browser canon
        if (Object.prototype.toString.call(window.zhf).slice(8, -1).toLowerCase() !== 'object') {
            window.zhf = {};
        }
        window.zhf[name] = factory();
    }
})('moduleCompat', function () {
    function moduleCompat() {
        console.log('moduleCompat');
    }

    return moduleCompat;
});
```

# 模块有依赖时需要注意
* 如果模块里依赖了别的模块，则上述的兼容方式是行不通的。以上的模块兼容，只适用于无依赖的单一模块。
    - 如果模块无依赖，则上述的模块兼容方式适用于：commonjs规范、amd规范、浏览器的命名空间规范。
* commonjs规范有依赖时(nodejs)，怎么引入依赖：
```
require('./xxx.js');
require('./yyy.js');
```
* amd规范依赖时(requirejs)，怎么引入依赖：
```
define(function (require, export, module, js5) {
    require('./xxx.js');
    require('./yyy.js');
});
```
* 普通浏览器命名空间规范有依赖时，怎么引入依赖：
```
window.zhf.xxx = function () {}
window.zhf.yyy = function () {}
```

# es6模块
* es6规范怎么导出模块：
    - xxx.js
    ```
    export default function xxx() {}
    ```
    - yyy.js
    ```
    export default function yyy() {}
    ```
* es6规范怎么导入依赖：
```
improt xxx form './xxx.js';
improt yyy form './yyy.js';
```
* es6怎么导出一个json对象：待续...
* ex6怎么导出一个数组：待续...
