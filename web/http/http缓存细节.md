# 304 Not Modified
* 在客户端向服务端发送http请求时，若返回状态码为`304 Not Modified`则表明此次请求为条件请求。在请求头中有两个请求参数：`If-Modified-Since`和`If-None-Match`。
* 当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候，就会发送一个条件请求。
  - 在进行条件请求时，客户端会提供给服务器一个`If-Modified-Since`请求头，其值为服务器上次返回响应头中`Last-Modified`值。
  - 还会提供一个`If-None-Match`请求头，其值为服务器上次返回的`ETag`响应头的值。
* 服务器会读取到这两个请求头中的值，判断出客户端缓存的资源是否是最新的，如果是的话，服务器就会返回`304 Not Modified`状态码，但没有响应体。客户端收到304响应后，就会从本地缓存中读取对应的资源。
# 200 OK (from disk cache) 和 200 OK (from memory cache)
* 不对服务器进行请求，直接使用本地缓存。
* 先缓存到磁盘，进程关闭，缓存依旧有效。
* 再缓存到内存，进程关闭，缓存立即失效。失效之后下次进来，会去磁盘找缓存，找到之后会再次缓存到内存。
* 注意：如果文件过大，则只会被缓存到disk，不会被缓存到memory。
# 200 OK (from service worker)
* 如果使用了html5的离线存储功能（PWA）（Manifest）（Service Worker）。
* 被缓存住的资源会返回：`200 OK (from service worker)`。

## 缓存特性 - 下述均为个人亲测
> 服务端工具：nginx/1.21.6
>
> 客户端工具：Chrome浏览器/105.0.5195.54
* 场景1：不配置任何缓存时。
  - `Status Code`次次是`200 OK`。在`iframe`中亦如此。
* 场景2：只让`Last-Modified`生效或只让`ETag`生效或让两者同时生效时。
  - `Status Code`首次是`200 OK`，后续是`200 OK (from memory cache)`。
  - 发现问题：明明只配置了弱缓存，为什么强缓存生效了？答案可参考下文案例分析。
* 场景3：只让`Last-Modified`生效或只让`ETag`生效或让两者同时生效时。若额外配置`Cache-Control no-cache;`或额外配置`Cache-Control max-age=0;`。
  - `Status Code`首次是`200 OK`，后续是`304 Not Modified`。在`iframe`中亦如此。
* 场景4：只让`Last-Modified`生效或只让`ETag`生效或让两者同时生效时。若额外配置`Cache-Control no-store;`。
  - `Status Code`首次是`200 OK`，后续是`200 OK`。在`iframe`中亦如此。
#### 知识点补充：Cache-Control强缓存？
* 单位：`Cache-Control: public, max-age=31536000`（秒）。
  - 使用nodejs的框架express设置这个缓存的时候是通过毫秒数设置的。
  - 使用nginx设置这个缓存的时候是通过秒数设置的。
  - 浏览器的响应头里显示出来是秒数。
* 注意1：Cache-Control并不是对所有的请求都有效。
* 注意2：当Cache-Control应用在XHR上时，对GET和HEAD请求有效，对POST请求无效。
* 浏览器会先校验强缓存是否有效，再校验协商缓存是否有效。
#### 知识点补充：若给静态资源配上强缓存，那么首条请求的强缓存特性是怎样的呢？
* 什么是首条请求？
  - 顾名思义，首条请求就是第一条请求。
  - 案例1：例如你把某个网页的地址，贴入到浏览器的地址栏中，对index.html页面发起的请求就是首条请求。
  - 案例2：例如你把某个远程css文件，贴入到浏览器的地址栏中，对这个css发起的请求就是首条请求。
* 特性：只有触发了浏览器的刷新行为，首条请求的强缓存才会失效（失效后，有弱缓存则返回304，无弱缓存则返回200 OK）。例如点击浏览器的刷新按钮或通过js进行页面刷新。
  - 注意1：在地址栏贴入已访问过的网址，并不一定会触发浏览器的刷新行为。
    - 假设你访问过A网页，则A网页的index.html会被浏览器进行强缓存。
    - 此时，如果你新开一个或多个tab，并逐个贴入A网页的链接，然后逐个进行回车，则首条请求的强缓存依然生效。
      - 无强缓存时，新开tab，逐个贴入，若页面有改动，则会立即请求最新的页面。
    - 但是，如果你对tab进行了2次回车，则首条请求的强缓存立即失效。
  - 注意2：浏览器的前进按钮和后退按钮以及a标签跳转和js跳转都不会让首条请求的强缓存失效。
  - 注意3：普通刷新（f5）会让首条请求的强缓存失效（非首条请求的强缓存依然有效）。强制刷新（ctrl+f5）会让所有请求的强缓存失效（通过js渲染iframe时例外，可参考下文案例分析）。
#### 知识点补充：七牛的缓存？
* 如果是使用的七牛，不管是html还是css亦或是js，只要文件被访问一次，就会一直被缓存。
* 因为七牛自带cdn，文件被缓存到了七牛的cdn服务器上。
* 即使强刷浏览器，删除七牛上的文件，更换七牛上的文件，都无用，缓存一直都在。
* 清除七牛的缓存方案1：去七牛后台手动清除对应文件的缓存（只会清除服务器上的缓存）。然后再刷新浏览器，清除首条请求在浏览器中的强缓存（或强刷清除全部请求的强缓存）。
* 清除七牛的缓存方案2：给url上加个`?t=时间戳`使之溯源。此方案是清理各种缓存的通用解决方案，不仅能清除本地缓存，还能清除CDN缓存，我个人强烈推荐。
#### 知识点补充：清理缓存？
* 清理缓存方式1：给url上加`?t=时间戳`。不管是七牛服务器的缓存还是浏览器的本地强缓存，都可以清理掉。
* 清理缓存方式2：给html的响应头设置Cache-Control为no-cache。仅用于规避本地缓存，无法规避CDN缓存。
  - 弱缓存存在则返回`304 Not Modified`。
  - 弱缓存不存在则返回`200 OK`。
#### 案例分析
* 场景描述：父页面中通过iframe内嵌了一个子页面。
  - 子页面index.html的响应头里不存在`Cache-Control`强缓存，只存在`Last-Modified`和`ETag`这两个弱缓存。
  - 但是子页面index.html的状态码居然返回了`200 OK (from memory cache)`。
* 问：子页面为什么会被强缓存？明明只配置了弱缓存，为什么强缓存生效了？
  - Chrome浏览器特性如此，有弱缓存时会默认生效强缓存。即有弱缓存时，则强缓存Cache-Control自动生效，其默认值是private。
  - 有弱缓存时，如果你要启用`304 Not Modified`，即304缓存，你应该在响应头里把Cache-Control设置为no-cache。无弱缓存时会返回`200 OK`。
  - 有弱缓存时，如果你要启用`200 OK`，即完全不缓存，你应该在响应头里把Cache-Control设置为no-store。无弱缓存时亦返回`200 OK`。
  - 无弱缓存亦无强缓存时，次次返回`200 OK`，iframe亦如此。无弱缓存，强缓存Cache-Control为private或no-cache或no-store时，次次返回`200 OK`，iframe亦如此。
  - 注：有弱缓存时，默认生效的强缓存，其机制难以捉摸。在iframe中，其有效期存在不确定性，时常会遇到页面已发布但缓存不失效的情况。应当给html的响应头配置Cache-Control为no-cache，使之返回304，用以规避这种难以琢磨的特性。
    - 难以捉摸的点1：在iframe中使用时，有时20秒有时30分钟会失效一次（所有静态资源返回304）。但有时又不失效。
    - 难以捉摸的点2：在tab中首次贴入时，有时20秒有时30分钟会失效一次（只有页面返回304）。但有时又不失效。
* 问：强刷父页面能去除子页面的缓存么？
  - 答：若iframe是通过js进行渲染的，同步渲染时强刷能去除掉非html页面的强缓存。异步渲染时强刷所有静态资源强缓存依旧存在。
  - 答：若iframe是通过html直接渲染的，强刷有用，可以去除掉所有静态资源的强缓存。即使有用，让用户去强刷页面也是不合理的行为。
* 问：能去给nginx配置`Cache-Control no-cache;`，让子页面的强缓存无效么？
  - 答：可以配。但是这个配置只能清理客户端的本地缓存，无法清理服务端的CDN缓存。如果客户端的页面已经被缓存住了，需要等缓存失效之后，这个配置才会生效。
  - 若是配置，建议只给index.html配置，我配置时没配置成功。因为我不想其他非html的静态资源也失去强缓存。
  - 若其他非html的静态资源都放在第三方的cdn服务器上，nginx中只有index.html页面，那直接对根路径进行无强缓存配置即可。
* 问：能去给子页面的index.html文件加meta标签，使之`Cache-Control`失效么？
  - 答：不能。因meta标签设置缓存的解析实现不是所有浏览器都支持，至少Chrome浏览器就不支持。
* 问：如何清理缓存？
  - 答：在页面的入口处加上时间戳进行缓存清理是最优解。不仅能清除本地缓存，还能规避CDN缓存。
  - 单页hash模式清理缓存：http://localhost:3080/?t=1662118978358/#/about?a=1&b=2
    - 注意事项1：只能把时间戳加到`#`号前面，因`#`号后面的数据，发请求时会被浏览器忽略掉。
    - 注意事项2：如果路由版本过低，可能存在不支持这种路由的情况（react18和vue3的配套路由支持上述路径）。
      - angular14的配套路由虽然不支持上述格式，但是可以正常渲染，同样也能达到清理缓存的目的。
      - 因为它会进行路由替换（替换时会把`#`号前面的时间戳清理掉），不过替换的时候缓存已被清理掉（因时间戳是先生效后被替换掉）。
    - 注意事项3：路径中多了一个`?`号，以前用js处理url的地方可能要进行改动。
  - 单页history模式清理缓存：http://localhost:3080/about?a=1&b=2&t=1662118978358
    - 注意事项1：单页history模式想要刷新不出现404，需要对nginx进行额外配置。
    - 注意事项2：如果是hash模式切换成history模式，以前用js处理url的地方可能要进行改动。

# `location.hash` 和 `location.search`
* 案例网址：http://localhost:3080/?a=1?b=2/#/about?c=3/#/d=4
* location.hash的值：`#/about?c=3/#/d=4`。
* location.search的值：`?a=1?b=2/`。
