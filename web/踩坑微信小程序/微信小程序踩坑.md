# 微信开发者工具
* 编译模式，定格在某一个页面时，启动参数设置成：?id=3549。导致一直报错
    - 解决方案，去掉问号(?)。

# 跳转
* wx.navigateTo
    - 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。
* wx.redirectTo
    - 关闭当前页面，跳转到应用内的某个页面。
* wx.reLaunch
    - 关闭所有页面，打开到应用内的某个页面。
* wx.switchTab
    - 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。

# 页面之间传值
* 方式1
```
// 在首页，使用api跳转到详情页
wx.navigateTo('/pages/detail/detail/?id=1');
// 在详情页页面中的onLoad方法中接收
Page({
    onLoad(query) {
        console.log('接收数据', query);
    },
});
```
* 方式2
```
// app.js里定义一个全局变量。
App({
    globalData: {},
});
// 跳转到别的页面的时候，可以更改这个值。
const app = getApp();
app.globalData.key1 = 'value1';
// 在其他页面就可以拿到这个值了。
const app = getApp();
console.log('数据', app.globalData.key1);
```
* 方式3
```
// 通过本地存储，跳转页面之前设置一个值。
wx.setStorage('key1', 'value1'); // 异步的
wx.setStorageSync('key1', 'value1'); // 同步的
// 到另外一个页面时，再接收这个值。
wx.getStorage('key1', 'value1'); // 异步的
wx.getStorageSync('key1', 'value1'); // 同步的
```

# 事件传参
```
// wxml
<view bindtap="fnClick" data-id="123"></view>
// js
Page({
    fnClick(ev) {
        console.log('数据', ev.currentTarget.dataset.id);
    },
});
```

# 定时器
* 页面卸载要清理掉定时器，否则会导致报错（以前会导致报错）。如果不清理掉，定时器会一直走着。

# WebStorm 格式化
* WebStorm 格式化wxss文件时，导致数值和单位之间有空格，正常应该是20rpx，编辑器格式化成了20 rpx导致无效。
    - 解决方案，不格式化，或者使用sass工具，封装个函数去转义。
    ```
    @function px2rpx($px) {
      @return $px * 1rpx;
    }
    ```

# 针对某一个页面进行下拉刷新
* index.json里加上window:{enablePullDownRefresh:true}，下拉刷新无效。
    - 解决方案：需要注意的是在需要下拉刷新的页面设置json时，直接写enablePullDownRefresh属性就行了，不需要写window。
* 下拉刷新，重新执行onLoad，组件内部数据没更新。
    - 解决方案：先把数据变成空，然后再重新赋值。然后关闭下拉刷新。wx.stopPullDownRefresh();
    - 新坑：重新执行onLoad()，导致onLoad(options){}函数中，options变为了undefined。
    - 新坑解决方案：把options存在data上，刷新时把数据带过去即可```this.onLoad(this.data.options)```。

# canvas组件
* canvas-id属性如果不加，canvas组件会一直是display:none。
    - 注意：不是id属性，是canvas-id属性。
* canvas 让px可以自适应，原理就是等比缩放。
```
function px2remCanvas(px) {
    return px * wx.getSystemInfoSync().windowWidth / 375; // 设计图是375的。
}
```
* canvas转图片时：1、canvas里用wx.drawImage插入的图片，真机本地预览进行测试，发现图片不显示。2、导出的图片变形了。3、导出的图片没有背景色。
    - 1、解决方案之wx.drawImage插入的图片，真机本地预览进行测试，发现图片不显示：
        - 1、图片需要是本地图片。
        - 2、不支持svg格式。
        - 3-1、远程图片需要下载到本地 可以使用wx.downloadFile方法或者wx.getImageInfo方法。
        - 3-2、远程图片仅支持https协议的图片。
        - 3-3、开发者工具，预览时用真机是无效的，预览开启调试模式时真机是有效的，远程调试时用真机是有效的。
        - 3-4、调试模式，不校验域名。导致真机上wx.drawImage无效的原因是，网络图片的链接不在小程序的信任列表中，需要管理员去后台把链接加入白名单。
        - 3-5、downloadFile，需要在小程序公众后台配置相应的downloadFile域名，否则会无法正常使用。
    - 2、解决问题之宽高不对：
        - 1、因为wx.canvasToTempFilePath方法导出的图片默认宽高是小程序去掉顶部菜单的宽高（如果画布的宽高不是这个比例，则导出的图片会变形），应该设置成画布的宽高乘以对应的倍数，先3倍吧。
        - 2、然后再配合wx.saveImageToPhotosAlbum方法进行导出。
    - 3、解决方案之背景色无效：因为我使用的是css的背景色，所以无效，背景色应该也要使用canvas绘画出来。
* canvas海报太慢了。
    - 解决方案：下载一次就存储起来，把原url也存储起来。如果原url更新了（图片更新了），就重新下载并存储。
    - 如果还觉的慢，就在前一个页面进行提前下载并存储，让用户无感知。然后来到当前页时，判断，如果前一个页面已经把图片下载好了，就直接使用，否则当前页进行重新下载并存储。
    - 注意事项：如果你是判断存储的已经有了，就直接使用存储的。那么你就需要去注意后续的数据更新，例如海报图片更换了，你就要重新生成最新的海报。
* 如果使用v-if控制canvas，下次显示时，会导致绘画无效，原因没有排查。建议使用display:none和display:block控制canvas的显示隐藏。
* font
    - 微信小程序中，font属性对应的值里，如果fontSize带小数，会导致设置失败，变成默认的10px sans-serif。浏览器中无这种问题。
    - 解决方案：向下取整。向上取整。四舍五入。
* 微信小程序中，canvas绘画时，在代码最后，代码最后，代码最后要执行一次ctx.draw();方法。绘制的才有效果。
* clip路径裁切，如果在save和restore之间，可以直接裁切，不用担心后面被影响，如果不是的话。建议fill填充一下，否则后续别的路径填充如果影响到了，会导致覆盖掉填充的图片（微信小程序模拟器上才有这个坑）。真机测试不fill一下，也是可行的。
* ctx.scale真机上导致多次缩放。
    - h5的canvas使用save和restore可以解决这种问题。
    - 微信开发者工具的模拟器上没有这种问题。
    - 真机上难道只能内部处理坐标么？是的，真机上我目前的解决方案是，内部坐标封装函数进行缩放处理。
    ```
    const px2remCanvas = function (px) { // canvas自适应
        return px * wx.getSystemInfoSync().windowWidth / 375; // 设计图是375的。
    };
    const px2px = function (px) { // canvas缩放
        return px2remCanvas(px) * scale; // scale是canvas的缩放比例。
    };
    ```

# webview组件
* webview内h5页面回跳小程序，直接运行js回跳无效。
    - 解决方案：加定时器。
    ```
    setTimeout(function () {
        // 此处运行js，跳回小程序，不加定时器回跳无效。原因不知，解决方案是我猜出来的。
    }, 60);
    ```

# 页面转发
* 如果Page上配置的有onShareAppMessage方法，右上角菜单就可以有转发功能，当然，不想有转发功能，去掉就行了。例如分销员页面，有些人开启了，有些人没开启，所以就不能有转发，否则需要判断跳转。
* 在return的对象{}中，加上success回调，即可监听到转发成功。
* 配置了onShareAppMessage方法之后怎么禁止掉右上角的转发？
    - 解决方案：在页面监听事件的onLoad事件中，直接触发wx.hideShareMenu();即可屏蔽右上角的转发。
* 分享转发的网络图片，域名也需要在小程序管理后台的下载域名列表里添加了才可以转发出去。

# getStorageSync
* ```wx.getStorageSync('distributor_id')```。如果在data时就赋值获取或者直接值赋给一个变量，在某些机型会丢值。真是见了鬼了，这根本无解好吧，原因不明。
    - 我怀疑是SDK版本问题。因时间原因（通宵上线，先保障功能正常，不能浪费大家的时间），不能在有问题的机器上进行测试。
    - 解决方案：哪里需要就直接获取```wx.getStorageSync('distributor_id')```。当然同事也更换了版本(2.2.2 -> 2.2.5)。因两者是同时进行，所以到底是这么解决的，有待考察。
    - 我本地用的2.0.4版本，未发现异常。不使用变量赋值之后，同事将SDK切回2.2.2版本，发现也可以获取到数据了，可是这让人无法理解啊。虽然事实摆在眼前，但是我个人仍然感觉是SDK版本有问题的可能性更高一点。

# bindblur
* 真机测试：输入完毕点击按钮的一瞬间是空值。
    - 解决方案1：使用bindinput代替bindblur。
    - 解决方案2：点击之后，延迟一下，个人不喜欢这种方式。

# onShow
* 因为使用onShow，data上的数据，不会每次都初始化。例如默认isShow1是false。isShow2是false。满足条件则变为true。
    - 第一次进来时，满足条件我让isShow1变成了true。
    - 第二次进来时，满足条件我让isShow2变成了true。但是我还要isShow1变成默认的false。
        - 此时，data上的数据是不会自动初始化把isShow1变成false的。
        - 需要手动把isShow1和isShow2变成false，然后继续打接口判断，满足条件让对应的变成true。
* 总结：onShow不会初始化data上的数据，如果需要初始化，则需要手动处理。

# 回退，数据不更新，还是老数据
* 解决方案：onShow里调this.onLoad();但是这样做，有问题，因为初始访问会同时调用onLoad和onShow，所以正确解法是：使用onShow代替onLoad即可。
* 如果onload里有options，把options存到data上，然后调用this.onLoad(this.data.options);
* onShow不会更新data上的数据，有些状态如果需要初始化，则需要手动进行初始化。特别是一些按钮默认隐藏，后续触发了显示，可能就一直显示了。需要在onShow时，全部重置成不显示的。

# button组件去掉默认边框和圆角
* button组件上的边框和圆角是写在伪元素after上的，所以要对伪元素after处理才行。

# wx.login 和 wx.getUserInfo 以及获取手机号和获取openid
* wx.login可以用来获取临时登录凭证code，然后使用这个凭证code可以获取session_key 和 openid 等。
* wx.getUserInfo授权之后才能使用。```<button open-type="getUserInfo" bindgetuserinfo="bindGetUserInfo">点击进行授权登录</button>```
* 获取openid：
```
getOpenId(callback) {
  const that = this;
  const openId = wx.getStorageSync('open_id');
  if (openId) {
    callback(openId);
  } else {
    wx.login({
      success({ code }) {
        const userInfo = wx.getStorageSync('userInfo'); // 此处建议使用wx.getUserInfo。且建议不缓存。否则后续更新是个问题（后续需要更新的数据，都不建议进行长期存储）。
        that.ajax({
          url: 'wechat/getOpenId',
          data: { code, ...userInfo },
          isOpenId: true,
          success({ data }) {
            if (data.res === 'succ') {
              const result = data.result || {};
              userInfo.tel = result.tel || '';
              wx.setStorageSync('userInfo', userInfo);
              wx.setStorageSync('open_id', result.openid);
              wx.setStorageSync('session_key', result.session_key);
              callback(result.openid);
            }
          },
        });
      },
    });
  }
}
```
* 获取手机号：```<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber">授权手机号</button>```
```
getPhoneNumber(e) {
  const that = this;
  if (e.detail.errMsg === 'getPhoneNumber:ok') {
    ApiWechat.getPhone({
      data: {
        iv: e.detail.iv,
        encryptedData: e.detail.encryptedData,
      },
      callback(res) {
        if (res.phoneNumber) {
          that.setData({ show: false });
          app.globalData.userInfo.tel = res.phoneNumber;
          that.setMsg();
        }
      },
    });
  }
}
```

# App有onLaunch没有onLoad
* Page有onLoad没有onLaunch
* App和Page都有onShow和onHide

# 函数封装
* 源码：https://github.com/zhouhuafei/zhf.canvas-api/blob/master/src/index.js
* 功能：绘制多行文字，绘制圆角矩形等。

# 其他
* 微信小程序中是没有Image，document，window等BOM和DOM对象的。

# rpx
* 750设计图 1rpx等于1px。
    - 单位要写成rpx。
* 375设计图 1rpx等于0.5px。1px等于2rpx。
    - 375设计图，量取的单位是10px，则要写成20rpx。建议使用scss处理。
* 如果你直接使用px作为单位，则微信会把1px转成2rpx。（注意，注意，注意，其实这里不是微信转的，是工具postcss转的。所以这里的总结是错误的。）
    - 个人觉的这里是为了兼容某些手机端ui框架，因大多数手机端ui框架都是使用的px。
    - px单位的ui组件可以使用postcss转成rem的。

# swiper
* 内嵌能在可视区展示的canvas组件会导致卡顿。
* 如果内部想展示，使用image组件展示即可。把canvas转成base64形式的数据，然后赋值给图片的src，即可展示出来。
* 可使用npm上的upng-js包模块的encode方法配合wx.arrayBufferToBase64方法实现功能。
* 坑点：canvasGetImageData需要在canvas绘画完毕之后进行获取。否则会是空的。draw的回调中还是需要定时器配合，否则获取还是为空，这可能是个bug。
```
// 绘制海报1
drawGoodsPoster1(v, v.scale, () => {
  setTimeout(() => {
    const w = Math.floor(v.width * getCanvasRatio()); // 因canvas自适应，这里要处理一下，此处得到的是自适应之后canvas的宽。
    const h = Math.floor(v.height * getCanvasRatio()); // 因canvas自适应，这里要处理一下，此处得到的是自适应之后canvas的宽。
    wx.canvasGetImageData({
      canvasId: v.id,
      x: 0,
      y: 0,
      width: w,
      height: h,
      success(res) {
        const arrayBuffer = upng.encode([res.data.buffer], w, h); // 转成utf-8数据
        v.imageBase64 = `data:image/png;base64,${wx.arrayBufferToBase64(arrayBuffer)}`;
        self.setData({ canvasSave });
        console.log(`canvasGetImageData${i}：`, res, arrayBuffer, v.imageBase64, getCanvasRatio(), v.width, v.height, w, h);
      },
    });
  }, 500);
});
```
* wx.canvasGetImageData在性能不好的机器上连续调用两次，即使使用了定时器延迟，也是会failm，所以以上方法行不通。
    - 使用wx.canvasToTempFilePath返回url直接给image组件使用即可。没必要使用base64。

* 获取用户信息失败，说明没授权登录，或者授权登录失效。
    - 需要把用来判断是否登录的字段移除掉。以保证可以再次跳到授权页面。
    ```
    wx.getUserInfo({
        success: (res) => {
        },
        fail: (err) => {
            console.log(err);
            wx.removeStorageSync('isLogin'); // 获取用户信息失败，说明没授权登录，或者授权登录失效。移掉此项，后续判断是否登录就通不过了，可以避免不必要的bug。
        },
    });
    ```

* 有open_id就算是登陆了。但是如果获取不到userInfo或者授权过期导致获取失败也是问题。
    - 所以正确逻辑应该是有open_id以及userInfo才算登录。
    - 封装login方法，在里面获取open_id以及userInfo。获取open_id成功则存储起来，获取userInfo成功则存一个hasUserInfo:true。因open_id不会变动，userInfo会变动，会变的都不建议存储起来。
    - 封装isLogin方法，在storage中检测到open_id以及hasUserInfo就算是登陆了。
    - 处理wx.getUserInfo方法。如果获取用户信息失败(如果失败原因是用户未授权)，就移掉关键字段open_id或者hasUserInfo(让isLogin方法通不过)，并跳转到授权登录页进行登录。

* project.config.json应该添加到git的版本库。
    - 如果不同的线对应着不同的品牌小程序，例如微好店小程序和微商城小程序，代码相同，appid不同。
    - 如果不在git的版本库里，做项目的时候，一切线，appid没变化，就会有问题。如此情况就只能曲线救国，例如用git再拉一份代码进行配置。
    - 如果在git的版本库里，就不会出现上面这种狗血的问题。

# css
* 不支持```*```号匹配。
* 不支持```.div > :nth-child(n){}```。
* 不支持使用本地背景图片。
