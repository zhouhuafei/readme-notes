# 微信开发者工具
* 编译模式，定格在某一个页面时，启动参数设置成：?id=3549。导致一直报错
    - 解决方案，去掉问号(?)。

# 跳转
* wx.navigateTo
    - 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。
* wx.redirectTo
    - 关闭当前页面，跳转到应用内的某个页面。
* wx.reLaunch
    - 关闭所有页面，打开到应用内的某个页面。
* wx.switchTab
    - 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。

# 页面之间传值
* 方式1
```
// 在首页，使用api跳转到详情页
wx.navigateTo('/pages/detail/detail/?id=1');
// 在详情页页面中的onLoad方法中接收
Page({
    onLoad(query) {
        console.log('接收数据', query);
    },
});
```
* 方式2
```
// app.js里定义一个全局变量。
App({
    globalData: {},
});
// 跳转到别的页面的时候，可以更改这个值。
const app = getApp();
app.globalData.key1 = 'value1';
// 在其他页面就可以拿到这个值了。
const app = getApp();
console.log('数据', app.globalData.key1);
```
* 方式3
```
// 通过本地存储，跳转页面之前设置一个值。
wx.setStorage('key1', 'value1'); // 异步的
wx.setStorageSync('key1', 'value1'); // 同步的
// 到另外一个页面时，再接收这个值。
wx.getStorage('key1', 'value1'); // 异步的
wx.getStorageSync('key1', 'value1'); // 同步的
```

# 事件传参
```
// wxml
<view bindtap="fnClick" data-id="123"></view>
// js
Page({
    fnClick(ev) {
        console.log('数据', ev.currentTarget.dataset.id);
    },
});
```

# 定时器
* 页面卸载要清理掉定时器，否则会导致报错（以前会导致报错）。如果不清理掉，定时器会一直走着。

# WebStorm 格式化
* WebStorm 格式化wxss文件时，导致数值和单位之间有空格，正常应该是20rpx，编辑器格式化成了20 rpx导致无效。
    - 解决方案，不格式化，或者使用sass工具，封装个函数去转义。
    ```
    @function px2rpx($px) {
      @return $px * 1rpx;
    }
    ```

# 针对某一个页面进行下拉刷新
* index.json里加上window:{enablePullDownRefresh:true}，下拉刷新无效。
    - 解决方案：需要注意的是在需要下拉刷新的页面设置json时，直接写enablePullDownRefresh属性就行了，不需要写window。
* 下拉刷新，重新执行onLoad，组件内部数据没更新。
    - 解决方案：先把数据变成空，然后再重新赋值。然后关闭下拉刷新。wx.stopPullDownRefresh();
    - 新坑：重新执行onLoad()，导致onLoad(options){}函数中，options变为了undefined。
    - 新坑解决方案：把options存在data上，刷新时把数据带过去即可```this.onLoad(this.data.options)```。

# canvas组件
* canvas-id属性如果不加，canvas组件会一直是display:none。
    - 注意：不是id属性，是canvas-id属性。
* canvas 让px可以自适应，原理就是等比缩放。
```
function px2px(px) {
    return px * wx.getSystemInfoSync().windowWidth / 375; // 设计图是375的。
}
```
* canvas转图片时：1、canvas里用wx.drawImage插入的图片，真机本地预览进行测试，发现图片不显示。2、导出的图片变形了。3、导出的图片没有背景色。
    - 1、解决方案之wx.drawImage插入的图片，真机本地预览进行测试，发现图片不显示：
        - 1、图片需要是本地图片。
        - 2、不支持svg格式。
        - 3-1、远程图片需要下载到本地 可以使用wx.downloadFile方法或者wx.getImageInfo方法。
        - 3-2、远程图片仅支持https协议的图片。
        - 3-3、开发者工具，预览时用真机是无效的，预览开启调试模式时真机是有效的，远程调试时用真机是有效的。
        - 3-4、调试模式，不校验域名。导致真机上wx.drawImage无效的原因是，网络图片的链接不在小程序的信任列表中，需要管理员去后台把链接加入白名单。
        - 3-5、downloadFile，需要在小程序公众后台配置相应的downloadFile域名，否则会无法正常使用。
    - 2、解决问题之宽高不对：
        - 1、因为wx.canvasToTempFilePath方法导出的图片默认宽高是小程序去掉顶部菜单的宽高（如果画布的宽高不是这个比例，则导出的图片会变形），应该设置成画布的宽高乘以对应的倍数，先3倍吧。
        - 2、然后再配合wx.saveImageToPhotosAlbum方法进行导出。
    - 3、解决方案之背景色无效：因为我使用的是css的背景色，所以无效，背景色应该也要使用canvas绘画出来。
* canvas海报太慢了。
    - 解决方案：下载一次就存储起来，把原url也存储起来。如果原url更新了（图片更新了），就重新下载并存储。
    - 如果还觉的慢，就在前一个页面进行提前下载并存储，让用户无感知。然后来到当前页时，判断，如果前一个页面已经把图片下载好了，就直接使用，否则当前页进行重新下载并存储。
    - 注意事项：如果你是判断存储的已经有了，就直接使用存储的。那么你就需要去注意后续的数据更新，例如海报图片更换了，你就要重新生成最新的海报。
* 如果使用v-if控制canvas，下次显示时，会导致绘画无效，原因没有排查。建议使用display:none和display:block控制canvas的显示隐藏。

# webview组件
* webview内h5页面回跳小程序，直接运行js回跳无效。
    - 解决方案：加定时器。
    ```
    setTimeout(function () {
        // 此处运行js，跳回小程序，不加定时器回跳无效。原因不知，解决方案是我猜出来的。
    }, 60);
    ```

# 页面转发
* 如果Page上配置的有onShareAppMessage方法，右上角菜单就可以有转发功能，当然，不想有转发功能，去掉就行了。例如分销员页面，有些人开启了，有些人没开启，所以就不能有转发，否则需要判断跳转。
* 在return的对象{}中，加上success回调，即可监听到转发成功。
* 配置了onShareAppMessage方法之后怎么禁止掉右上角的转发？
    - 解决方案：在页面监听事件的onLoad事件中，直接触发wx.hideShareMenu();即可屏蔽右上角的转发。

# getStorageSync
* ```wx.getStorageSync('distributor_id')```。如果在data时就赋值获取或者直接值赋给一个变量，在某些机型会丢值。真是见了鬼了，这根本无解好吧，原因不明。
    - 我怀疑是SDK版本问题。因时间原因（通宵上线，先保障功能正常，不能浪费大家的时间），不能在有问题的机器上进行测试。
    - 解决方案：哪里需要就直接获取```wx.getStorageSync('distributor_id')```。当然同事也更换了版本(2.2.2 -> 2.2.5)。因两者是同时进行，所以到底是这么解决的，有待考察。
    - 我本地用的2.0.4版本，未发现异常。不使用变量赋值之后，同事将SDK切回2.2.2版本，发现也可以获取到数据了，可是这让人无法理解啊。虽然事实摆在眼前，但是我个人仍然感觉是SDK版本有问题的可能性更高一点。

# bindblur
* 真机测试：输入完毕点击按钮的一瞬间是空值。
    - 解决方案1：使用bindinput代替bindblur。
    - 解决方案2：点击之后，延迟一下，个人不喜欢这种方式。

# onShow
* 因为使用onShow，data上的数据，不会每次都初始化。例如默认isShow1是false。isShow2是false。满足条件则变为true。
    - 第一次进来时，满足条件我让isShow1变成了true。
    - 第二次进来时，满足条件我让isShow2变成了true。但是我还要isShow1变成默认的false。
        - 此时，data上的数据是不会自动初始化把isShow1变成false的。
        - 需要手动把isShow1和isShow2变成false，然后继续打接口判断，满足条件让对应的变成true。
* 总结：onShow不会初始化data上的数据，如果需要初始化，则需要手动处理。

# 回退，数据不更新，还是老数据。
* 解决方案：onShow里调this.onLoad();
* 如果onload里有options，把options存到data上，然后调用this.onLoad(this.data.options);
* onShow不会更新data上的数据，有些状态如果需要初始化，则需要手动进行初始化。特别是一些按钮默认隐藏，后续触发了显示，可能就一直显示了。需要在onShow时，全部重置成不显示的。

# button组件去掉默认边框和圆角
* button组件上的边框和圆角是写在伪元素after上的，所以要对伪元素after处理才行。

# 函数封装
* 绘制多行文字
```javascript
function canvasDrawText(opts) { // canvas绘制多行文本，或者单行文本，超出显示省略号
    const ctx = opts.ctx; // 绘画环境
    const text = opts.text || ''; // 文本
    const x = opts.x || 0; // x轴坐标
    let y = opts.y || 0; // y轴坐标
    const fontSize = opts.fontSize || 12; // 文字大小
    const fontFamily = opts.fontFamily || 'sans-serif'; // 字体
    const lineHeight = opts.lineHeight || 18; // 行高，这里的数值是值像素，不是倍数。
    const lineWidth = opts.lineWidth || 300; // 行宽
    const lineNum = opts.lineNum; // 行数(默认不限制行数)
    const isFillEllipsis = opts.isFillEllipsis !== false; // 超出是否填充省略号(默认true)，默认false的写法：opts.isFillEllipsis === true;
    if (!ctx) {
        return;
    }
    ctx.font = `${fontSize}px ${fontFamily}`;
    ctx.textBaseline = 'middle';
    y = y + fontSize / 2 + (lineHeight - fontSize) / 2; // 重置y轴坐标到精准的位置。
    const items = [];
    let str = '';
    // 超过了宽度，则吧超过之前的字符放入items
    for (let i = 0; i < text.length; i++) {
        str += text[i];
        if (ctx.measureText(str).width > lineWidth) {
            items.push(str.substring(0, str.length - 1));
            str = '';
            i--;
        }
    }
    if (!items.length) { // 如果文本没超出单行宽度。
        items.push(text);
    } else { // 如果文本超出了单行宽度。
        // 如果存在剩余的，则把剩余的填入
        const endText = text.split(items.join(''))[1];
        if (endText) {
            items.push(endText);
        }
    }
    // 如果超出了指定行数。
    if (!isNaN(lineNum) && items.length > lineNum) {
        items.length = lineNum;
        if (isFillEllipsis) { // 如果做省略号填充
            let str = items[items.length - 1];
            const strLen = str.length;
            for (let i = 0; i < strLen; i++) {
                if (ctx.measureText(`${str}...`).width > lineWidth) {
                    str = str.substring(0, str.length - 1);
                } else {
                    items[items.length - 1] = `${str}...`;
                }
            }
        }
    }
    // 绘画文字
    items.forEach(function (v, i) {
        ctx.fillText(v, x, y + i * (fontSize + (lineHeight - fontSize) / 2));
    });
}
```
