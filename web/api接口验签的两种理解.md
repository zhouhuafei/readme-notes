# 验签生成规则
* 按照请求参数名称，将请求参数按顺序排列处理，进行算法加密。生成验签码sign。
    - 验签的唯一性。
* 参数带上时间戳。
    - 时间戳也要参与验签的加密。
    - 这样可以保证签名的时效性。
    - 后端会判断这个时间戳的时效性。
    - 比对参数上的stamp和服务器上的时间戳时，因为有误差，建议2-5分钟。

# 验签理解
* 1、没有中间层，直接前端请求api服务。
    - 此时验签只是为了防止用户恶意重复请求，防止篡改参数。
    - 加密算法但是很容易被破解，防君子不防小人。
    - 登录会有token，所以还算是安全的。
    - 此时验签和token都是明文暴露的。
* 2、有中间层，前端请求中间层，中间层再去根据验签规则去请求api服务。
    - 前端登录，直接请求中间层，中间层把token存session。
    - 此时验签是安全的。token是安全的。
    - 需要中间层启服务，转发api。
    - 本地开发如果和中间层分离了，会存在跨域问题以及sessionid丢失。可以使用服务器代理的方式解决。
    - 本地开发如果和中间层分离了，没有sessionid进行关联，怎么请求接口验证权限？使用代理服务器，例如使用webpack-dev-server或者browser-sync配置代理，这样sessionid也是可以回传的。
    - 本地开发如果和中间层分离了，没有sessionid进行关联，就无法做注册登录的图文验证码？可以做。可以先打一个获取sessionid的接口，如果使用上面一行里说到的代理是可以把sessionid拿到并设置到cookie上的，因为不存在跨域问题，否则即使获取到了sessionid也设置不到cookie上。
    - 此时用户可以恶意重复请求，如果要防止，则对中间层也做一次验签，这层验签是属于前端的验签，防君子不防小人，此时请用另一把验签秘钥，别傻傻的把api服务的验签秘钥暴露了。此层验签的功能只是为了防止重复请求和参数被篡改。
    - 但是就算是暴露了也没关系，毕竟api服务上还有一层token做权限验证。
    - 加中间层是为了保护api的验签和token。是为了更安全着想。

# 总结
* 前端的验签只是防君子不防小人，防止用户恶意重复请求以及防止篡改参数。
