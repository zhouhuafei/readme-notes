## 一面
* vue2和vue3的区别？
  - 底层实现响应式使用的api不同 vue2使用Object.defineProperty vue3使用Proxy+Reflect
  - vue3增加了Composition Api可以更好的进行逻辑服用 和 ts类型推导 以及Tree-shaking更小的打包体积
  - 另外就是使用时的一些注意事项 例如v-if的优先级比v-for更高 v-model的语法糖变化 支持多根节点等
* Object.defineProperty和Proxy的区别？
  - Object.defineProperty只能拦截对象已存在属性的读取和修改操作 Proxy可以拦截对象的所有操作
  - Object.defineProperty直接修改原对象 Proxy返回代理对象不修改原对象
  - Object.defineProperty对数组的拦截能力较弱 需要通过重写数组原型方法来间接实现对数组的拦截 Proxy支持拦截数组的所有操作
* vue3的Composition API怎么获取组件的实例？
  - getCurrentInstance
* ref和toRef和toRefs和reactive的区别？
  - ref用来将基本类型和引用类型转换为响应式对象 还可以用来获取组件实例或dom节点 通过.value访问
  - reactive将引用类型转换为响应式对象
  - toRef为reactive创建的响应式对象的某个属性创建一个ref 并保持响应式关联
  - toRefs将reactive创建的响应式对象的所有属性转换为一个ref对象集合 并保持响应式关联
* watch和watchEffect的区别？
  - watch需要明确指定监听的数据源 watchEffect会自动收集需要监听的数据源
  - watch回调函数可以同时获取新值和旧值 watchEffect回调函数无法直接获取旧值只能获取变化后的新值
  - watch是惰性执行需要把参数immediate设置为true才会立即执行 watchEffect会立即执行
  - watch需要把deep设置为true才会深度监听 watchEffect会自动进行深度监听
  - 两者都返回一个停止函数 调用后可停止监听
* 如何解决跨域问题？有哪些解决方案？
  - 响应头加Access-Control-Allow-Origin
  - 服务器代理
  - jsonp跨域 仅限Get请求
  - 使用iframe的postMessage进行跨域
  - document.domain跨子域
  - ws不存在跨域问题
* 什么情况下会触发Options请求？
  - xhr跨域的前提下
  - 是GET和HEAD请求时 有自定义请求头则触发
  - 是POST请求时 有自定义请求头则触发 如果不是标准的Content-type则触发 例如Content-type是application/json
  - 其他请求直接触发
* instanceof和typeof的区别？
* Object.prototype.toString.call的原理？
* this的指向？
* 箭头函数和普通函数的区别？
* xhr fetch axios的区别？
* Vue的设计模式是什么？
* Promise原理？
* async/await原理？
* 谈谈你对事件循环机制的了解？
* 说一下你对Service Worker的理解？
* 页面关闭之前，上报埋点数据，有哪些实现方式？
* 数组和链表的区别？

## 二面
* 有没有遇到列表卡顿的问题，怎么解决？
* 网页打开比较慢，怎么优化？
* 弱网环境，怎么处理？
* 手写题，找出数组中第三大的值？
