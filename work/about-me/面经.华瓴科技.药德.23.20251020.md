## 一面
* vue2和vue3的区别？
  - 底层实现响应式使用的api不同 vue2使用Object.defineProperty vue3使用Proxy+Reflect
  - vue3增加了Composition Api可以更好的进行逻辑服用 和 ts类型推导 以及Tree-shaking更小的打包体积
  - 另外就是使用时的一些注意事项 例如v-if的优先级比v-for更高 v-model的语法糖变化 支持多根节点等
* Object.defineProperty和Proxy的区别？
  - Object.defineProperty只能拦截对象已存在属性的读取和修改操作 Proxy可以拦截对象的所有操作
  - Object.defineProperty直接修改原对象 Proxy返回代理对象不修改原对象
  - Object.defineProperty对数组的拦截能力较弱 需要通过重写数组原型方法来间接实现对数组的拦截 Proxy支持拦截数组的所有操作
* vue3的Composition API怎么获取组件的实例？
  - getCurrentInstance
* ref和toRef和toRefs和reactive的区别？
  - ref用来将基本类型和引用类型转换为响应式对象 还可以用来获取组件实例或dom节点 通过.value访问
  - reactive将引用类型转换为响应式对象
  - toRef为reactive创建的响应式对象的某个属性创建一个ref 并保持响应式关联
  - toRefs将reactive创建的响应式对象的所有属性转换为一个ref对象集合 并保持响应式关联
* watch和watchEffect的区别？
  - watch需要明确指定监听的数据源 watchEffect会自动收集需要监听的数据源
  - watch回调函数可以同时获取新值和旧值 watchEffect回调函数无法直接获取旧值只能获取变化后的新值
  - watch是惰性执行需要把参数immediate设置为true才会立即执行 watchEffect会立即执行
  - watch需要把deep设置为true才会深度监听 watchEffect会自动进行深度监听
  - 两者都返回一个停止函数 调用后可停止监听
* 如何解决跨域问题？有哪些解决方案？
  - 响应头加Access-Control-Allow-Origin
  - 服务器代理
  - jsonp跨域 仅限Get请求
  - 使用iframe的postMessage进行跨域
  - document.domain跨子域
  - ws不存在跨域问题
* 什么情况下会触发Options请求？
  - xhr跨域的前提下
  - 是GET和HEAD请求时 有自定义请求头则触发
  - 是POST请求时 有自定义请求头则触发 如果不是标准的Content-type则触发 例如Content-type是application/json
  - 其他请求直接触发
* instanceof和typeof的区别？
  - instanceof主要用于检测引用数据类型 返回值是布尔类型
  - typeof主要用于检测基本数据类型 返回值是字符串类型
* Object.prototype.toString.call的原理？
  - Object.prototype.toString.call是一种精准检测数据类型的方法
  - 会返回当前对象的类型字符串 格式为`[object 类型名]`
  - 如果是自定义的构造函数 可以增加`this[Symbol.toStringTag] = 'A'`使之能被Object.prototype.toString.call识别
* this的指向？
  - 普通函数调用 非严格模式 浏览环境指向window node环境指向global 严格模式指向undefined
  - 对象调用方法时 this指向调用该方法的对象
  - 使用new调用构造函数时 this指向新生成的实例对象
  - 在DOM事件处理函数中 this指向触发该事件的DOM元素
  - 在nodejs的commonJs模块下 直接使用this时 this指向module.exports
* 箭头函数和普通函数的区别？
  - 箭头函数没有prototype属性
  - 箭头函数不能new
  - 箭头函数不能使用arguments
  - 箭头函数不会更改this的指向
  - 箭头函数中的this不受call、apply和bind影响
* xhr/fetch/axios的区别？
  - xhr是指XMLHttpRequest对象
  - axios是基于xhr进行封装的第三方库
  - fetch天然支持Promise/语法更简洁/支持流式数据接收 做AI助手时fetch很有用
* Vue的设计模式是什么？
  - Vue的设计模式是MVVM模式
  - M是Model模型 指应用的数据层 通常是纯JavaScript对象
  - V是View视图 指用户界面 负责数据的展示 是模型的可视化表现
  - VM是ViewModel视图模型 是连接 Model 和 View 的桥梁
  - Vue通过MVVM实现了数据与视图的自动同步 减少了手动操作DOM的工作
* Promise原理？
  - Promise是一种异步解决方案 其核心原理是通过状态管理和回调队列来处理异步操作
  - Promise有且仅有三种状态 且状态一旦改变就不可逆 初始是等待状态 可以使用resolve更改为成功状态并触发then和finally 使用reject更改为失败状态并触发catch和finally
  - resolve的入参如果是一个Promise 则会等待Promise处理完结果之后才会继续往下执行 reject不会等待
* async/await原理？
  - async/await是ES2017引入的语法糖 目的是让异步代码的写法更接近同步代码 解决了Promise链式调用可能带来的代码冗余问题
  - await需要在async中使用
  - await返回Promise对象的处理结果 如果等待的不是Promise对象 则返回该值本身
* 谈谈你对事件循环机制的理解？
  - 先执行同步任务 后执行异步任务
  - 异步任务分为微任务和宏任务
  - 优先执行微任务队列 清空完微任务队列之后 从宏任务队列取一个宏任务进行执行
  - 执行时遇到微任务则放入微任务队列 执行完这次宏任务之后 再去清空微任务队列
* 说一下你对Service Worker的理解？
  - Service Worker 是运行在浏览器后台线程的独立脚本，与网页主线程隔离，主要用于实现离线缓存、请求拦截、后台同步、消息推送等
  - Service Worker 必须在 HTTPS 环境下运行
* 页面关闭之前，上报埋点数据，有哪些实现方式？
  - 通常使用beforeunload事件配合navigator.sendBeacon进行实现
  - 也可以使用beforeunload事件配合fetch的keepalive:true选项让请求在页面关闭后继续完成
  - 还可以使用Service Worker的后台同步功能 即使页面关闭 也能在网络可用时进行上报 适合对可靠性要求极高的场景
* 数组和链表的区别？

## 二面
* 有没有遇到列表卡顿的问题，怎么解决？
* 网页打开比较慢，怎么优化？
* 弱网环境，怎么处理？
* 手写题，找出数组中第三大的值？
